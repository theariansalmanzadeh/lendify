{"version":3,"file":"static/js/577.39c2d799.chunk.js","mappings":"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","sources":["../node_modules/@ethersproject/providers/src.ts/_version.ts","../node_modules/@ethersproject/hash/src.ts/_version.ts","../node_modules/@ethersproject/hash/src.ts/typed-data.ts","../node_modules/@ethersproject/base64/src.ts/browser-base64.ts","../node_modules/@ethersproject/web/src.ts/_version.ts","../node_modules/@ethersproject/web/src.ts/browser-geturl.ts","../node_modules/@ethersproject/web/src.ts/index.ts","../node_modules/@ethersproject/basex/src.ts/index.ts","../node_modules/@ethersproject/hash/src.ts/ens-normalize/decoder.ts","../node_modules/@ethersproject/hash/src.ts/ens-normalize/lib.ts","../node_modules/@ethersproject/hash/src.ts/ens-normalize/include.ts","../node_modules/@ethersproject/hash/src.ts/namehash.ts","../node_modules/@ethersproject/networks/src.ts/_version.ts","../node_modules/@ethersproject/networks/src.ts/index.ts","../node_modules/@ethersproject/sha2/src.ts/browser-sha2.ts","../node_modules/@ethersproject/sha2/src.ts/_version.ts","../node_modules/@ethersproject/providers/src.ts/formatter.ts","../node_modules/@ethersproject/constants/src.ts/addresses.ts","../node_modules/@ethersproject/providers/src.ts/base-provider.ts","../node_modules/@ethersproject/constants/src.ts/hashes.ts","../node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts","../node_modules/@ethersproject/providers/src.ts/web3-provider.ts","../node_modules/@ethersproject/bignumber/src.ts/fixednumber.ts","../node_modules/@ethersproject/units/src.ts/index.ts","../node_modules/@ethersproject/units/src.ts/_version.ts","../node_modules/bech32/index.js"],"sourcesContent":["export const version = \"providers/5.7.2\";\n","export const version = \"hash/5.7.0\";\n","import { TypedDataDomain, TypedDataField } from \"@ethersproject/abstract-signer\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, hexConcat, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { id } from \"./id\";\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\n\nconst NegativeOne: BigNumber = BigNumber.from(-1);\nconst Zero: BigNumber = BigNumber.from(0);\nconst One: BigNumber = BigNumber.from(1);\nconst MaxUint256: BigNumber = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\nfunction hexPadRight(value: BytesLike) {\n    const bytes = arrayify(value);\n    const padOffset = bytes.length % 32\n    if (padOffset) {\n        return hexConcat([ bytes, padding.slice(padOffset) ]);\n    }\n    return hexlify(bytes);\n}\n\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\n\nconst domainFieldTypes: Record<string, string> = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\n\nconst domainFieldNames: Array<string> = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\n\nfunction checkString(key: string): (value: any) => string {\n    return function (value: any){\n        if (typeof(value) !== \"string\") {\n            logger.throwArgumentError(`invalid domain value for ${ JSON.stringify(key) }`, `domain.${ key }`, value);\n        }\n        return value;\n    }\n}\n\nconst domainChecks: Record<string, (value: any) => any> = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function(value: any) {\n        try {\n            return BigNumber.from(value).toString()\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n    },\n    verifyingContract: function(value: any) {\n        try {\n            return getAddress(value).toLowerCase();\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function(value: any) {\n        try {\n            const bytes = arrayify(value);\n            if (bytes.length !== 32) { throw new Error(\"bad length\"); }\n            return hexlify(bytes);\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n    }\n}\n\nfunction getBaseEncoder(type: string): (value: any) => string {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n\n            const width = parseInt(match[2] || \"256\");\n            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\n                logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n            }\n\n            const boundsUpper = MaxUint256.mask(signed ? (width - 1): width);\n            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne): Zero;\n\n            return function(value: BigNumberish) {\n                const v = BigNumber.from(value);\n\n                if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n                    logger.throwArgumentError(`value out-of-bounds for ${ type }`, \"value\", value);\n                }\n\n                return hexZeroPad(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\n                logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n            }\n\n            return function(value: BytesLike) {\n                const bytes = arrayify(value);\n                if (bytes.length !== width) {\n                    logger.throwArgumentError(`invalid length for ${ type }`, \"value\", value);\n                }\n                return hexPadRight(value);\n            };\n        }\n    }\n\n    switch (type) {\n        case \"address\": return function(value: string) {\n            return hexZeroPad(getAddress(value), 32);\n        };\n        case \"bool\": return function(value: boolean) {\n            return ((!value) ? hexFalse: hexTrue);\n        };\n        case \"bytes\": return function(value: BytesLike) {\n            return keccak256(value);\n        };\n        case \"string\": return function(value: string) {\n            return id(value);\n        };\n    }\n\n    return null;\n}\n\nfunction encodeType(name: string, fields: Array<TypedDataField>): string {\n    return `${ name }(${ fields.map(({ name, type }) => (type + \" \" + name)).join(\",\") })`;\n}\n\nexport class TypedDataEncoder {\n    readonly primaryType: string;\n    readonly types: Record<string, Array<TypedDataField>>;\n\n    readonly _encoderCache: Record<string, (value: any) => string>;\n    readonly _types: Record<string, string>;\n\n    constructor(types: Record<string, Array<TypedDataField>>) {\n        defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n\n        defineReadOnly(this, \"_encoderCache\", { });\n        defineReadOnly(this, \"_types\", { });\n\n        // Link struct types to their direct child structs\n        const links: Record<string, Record<string, boolean>> = { };\n\n        // Link structs to structs which contain them as a child\n        const parents: Record<string, Array<string>> = { };\n\n        // Link all subtypes within a given struct\n        const subtypes: Record<string, Record<string, boolean>> = { };\n\n        Object.keys(types).forEach((type) => {\n            links[type] = { };\n            parents[type] = [ ];\n            subtypes[type] = { }\n        });\n\n        for (const name in types) {\n\n            const uniqueNames: Record<string, boolean> = { };\n\n            types[name].forEach((field) => {\n\n                // Check each field has a unique name\n                if (uniqueNames[field.name]) {\n                    logger.throwArgumentError(`duplicate variable name ${ JSON.stringify(field.name) } in ${ JSON.stringify(name) }`, \"types\", types);\n                }\n                uniqueNames[field.name] = true;\n\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n                if (baseType === name) {\n                    logger.throwArgumentError(`circular type reference to ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) { return ;}\n\n                if (!parents[baseType]) {\n                    logger.throwArgumentError(`unknown type ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));\n\n        if (primaryTypes.length === 0) {\n            logger.throwArgumentError(\"missing primary type\", \"types\", types);\n        } else if (primaryTypes.length > 1) {\n            logger.throwArgumentError(`ambiguous primary types or unused types: ${ primaryTypes.map((t) => (JSON.stringify(t))).join(\", \") }`, \"types\", types);\n        }\n\n        defineReadOnly(this, \"primaryType\", primaryTypes[0]);\n\n        // Check for circular type references\n        function checkCircular(type: string, found: Record<string, boolean>) {\n            if (found[type]) {\n                logger.throwArgumentError(`circular type reference to ${ JSON.stringify(type) }`, \"types\", types);\n            }\n\n            found[type] = true;\n\n            Object.keys(links[type]).forEach((child) => {\n                if (!parents[child]) { return; }\n\n                // Recursively check children\n                checkCircular(child, found);\n\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype) => {\n                    subtypes[subtype][child] = true;\n                });\n            });\n\n            delete found[type];\n        }\n        checkCircular(this.primaryType, { });\n\n        // Compute each fully describe type\n        for (const name in subtypes) {\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\");\n        }\n    }\n\n    getEncoder(type: string): (value: any) => string {\n        let encoder = this._encoderCache[type];\n        if (!encoder) {\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n        }\n        return encoder;\n    }\n\n    _getEncoder(type: string): (value: any) => string {\n\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return encoder; }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value: Array<any>) => {\n                if (length >= 0 && value.length !== length) {\n                    logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n                }\n\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) {\n                    result = result.map(keccak256);\n                }\n\n                return keccak256(hexConcat(result));\n            };\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this._types[type]);\n            return (value: Record<string, any>) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) { return keccak256(result); }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return hexConcat(values);\n            }\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    encodeType(name: string): string {\n        const result = this._types[name];\n        if (!result) {\n            logger.throwArgumentError(`unknown type: ${ JSON.stringify(name) }`, \"name\", name);\n        }\n        return result;\n    }\n\n    encodeData(type: string, value: any): string {\n        return this.getEncoder(type)(value);\n    }\n\n    hashStruct(name: string, value: Record<string, any>): string {\n        return keccak256(this.encodeData(name, value));\n    }\n\n    encode(value: Record<string, any>): string {\n        return this.encodeData(this.primaryType, value);\n    }\n\n    hash(value: Record<string, any>): string {\n        return this.hashStruct(this.primaryType, value);\n    }\n\n    _visit(type: string, value: any, callback: (type: string, data: any) => any): any {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return callback(type, value); }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (length >= 0 && value.length !== length) {\n                logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n            }\n            return value.map((v: any) => this._visit(subtype, v, callback));\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, <Record<string, any>>{});\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    visit(value: Record<string, any>, callback: (type: string, data: any) => any): any {\n        return this._visit(this.primaryType, value, callback);\n    }\n\n    static from(types: Record<string, Array<TypedDataField>>): TypedDataEncoder {\n        return new TypedDataEncoder(types);\n    }\n\n    static getPrimaryType(types: Record<string, Array<TypedDataField>>): string {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n\n    static hashStruct(name: string, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n\n    static hashDomain(domain: TypedDataDomain): string {\n        const domainFields: Array<TypedDataField> = [ ];\n        for (const name in domain) {\n            const type = domainFieldTypes[name];\n            if (!type) {\n                logger.throwArgumentError(`invalid typed-data domain key: ${ JSON.stringify(name) }`, \"domain\", domain);\n            }\n            domainFields.push({ name, type });\n        }\n\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n\n    static encode(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return hexConcat([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n\n    static hash(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n\n    // Replaces all address types with ENS names with their looked up address\n    static async resolveNames(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, resolveName: (name: string) => Promise<string>): Promise<{ domain: TypedDataDomain, value: any }> {\n        // Make a copy to isolate it from the object passed in\n        domain = shallowCopy(domain);\n\n        // Look up all ENS names\n        const ensCache: Record<string, string> = { };\n\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n\n        // Get a list of all the addresses\n        encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && !isHexString(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n\n        // Lookup each name\n        for (const name in ensCache) {\n            ensCache[name] = await resolveName(name);\n        }\n\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && ensCache[value]) { return ensCache[value]; }\n            return value;\n        });\n\n        return { domain, value };\n    }\n\n    static getPayload(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): any {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n\n        // Derive the EIP712Domain Struct reference type\n        const domainValues: Record<string, any> = { };\n        const domainTypes: Array<{ name: string, type:string }> = [ ];\n\n        domainFieldNames.forEach((name) => {\n            const value = (<any>domain)[name];\n            if (value == null) { return; }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n\n        const encoder = TypedDataEncoder.from(types);\n\n        const typesWithDomain = shallowCopy(types);\n        if (typesWithDomain.EIP712Domain) {\n            logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        } else {\n            typesWithDomain.EIP712Domain = domainTypes;\n        }\n\n        // Validate the data structures and types\n        encoder.encode(value);\n\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type: string, value: any) => {\n\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return hexlify(arrayify(value));\n                }\n\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return BigNumber.from(value).toString();\n                }\n\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        if (typeof(value) !== \"string\") {\n                            logger.throwArgumentError(`invalid string`, \"value\", value);\n                        }\n                        return value;\n                }\n\n                return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function decode(textData: string): Uint8Array {\n    textData = atob(textData);\n    const data = [];\n    for (let i = 0; i < textData.length; i++) {\n        data.push(textData.charCodeAt(i));\n    }\n    return arrayify(data);\n}\n\nexport function encode(data: BytesLike): string {\n    data = arrayify(data);\n    let textData = \"\";\n    for (let i = 0; i < data.length; i++) {\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n}\n\n\n","export const version = \"web/5.7.1\";\n","\"use strict\";\n\nimport { arrayify } from \"@ethersproject/bytes\";\n\nimport type { GetUrlResponse, Options } from \"./types\";\n\nexport { GetUrlResponse, Options };\n\nexport async function getUrl(href: string, options?: Options): Promise<GetUrlResponse> {\n    if (options == null) { options = { }; }\n\n    const request: RequestInit = {\n        method: (options.method || \"GET\"),\n        headers: (options.headers || { }),\n        body: (options.body || undefined),\n    };\n\n    if (options.skipFetchSetup !== true) {\n        request.mode = <RequestMode>\"cors\";              // no-cors, cors, *same-origin\n        request.cache = <RequestCache>\"no-cache\";        // *default, no-cache, reload, force-cache, only-if-cached\n        request.credentials = <RequestCredentials>\"same-origin\";  // include, *same-origin, omit\n        request.redirect = <RequestRedirect>\"follow\";    // manual, *follow, error\n        request.referrer = \"client\";                     // no-referrer, *client\n    };\n\n    if (options.fetchOptions != null) {\n        const opts = options.fetchOptions;\n        if (opts.mode) { request.mode = <RequestMode>(opts.mode); }\n        if (opts.cache) { request.cache = <RequestCache>(opts.cache); }\n        if (opts.credentials) { request.credentials = <RequestCredentials>(opts.credentials); }\n        if (opts.redirect) { request.redirect = <RequestRedirect>(opts.redirect); }\n        if (opts.referrer) { request.referrer = opts.referrer; }\n    }\n\n    const response = await fetch(href, request);\n    const body = await response.arrayBuffer();\n\n    const headers: { [ name: string ]: string } = { };\n    if (response.headers.forEach) {\n        response.headers.forEach((value, key) => {\n            headers[key.toLowerCase()] = value;\n        });\n    } else {\n        (<() => Array<string>>((<any>(response.headers)).keys))().forEach((key) => {\n            headers[key.toLowerCase()] = response.headers.get(key);\n        });\n    }\n\n    return {\n        headers: headers,\n        statusCode: response.status,\n        statusMessage: response.statusText,\n        body: arrayify(new Uint8Array(body)),\n    }\n}\n","\"use strict\";\n\nimport { decode as base64Decode, encode as base64Encode } from \"@ethersproject/base64\";\nimport { hexlify, isBytesLike } from \"@ethersproject/bytes\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { getUrl, GetUrlResponse, Options } from \"./geturl\";\n\nfunction staller(duration: number): Promise<void> {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n\nfunction bodyify(value: any, type: string): string {\n    if (value == null) { return null; }\n\n    if (typeof(value) === \"string\") { return value; }\n\n    if (isBytesLike(value)) {\n        if (type && (type.split(\"/\")[0] === \"text\" || type.split(\";\")[0].trim() === \"application/json\")) {\n            try {\n                return toUtf8String(value);\n            } catch (error) { };\n        }\n        return hexlify(value);\n    }\n\n    return value;\n}\n\n// Exported Types\nexport type ConnectionInfo = {\n    url: string,\n    headers?: { [key: string]: string | number }\n\n    user?: string,\n    password?: string,\n\n    allowInsecureAuthentication?: boolean,\n    allowGzip?: boolean,\n\n    throttleLimit?: number,\n    throttleSlotInterval?: number;\n    throttleCallback?: (attempt: number, url: string) => Promise<boolean>,\n\n    skipFetchSetup?: boolean;\n    fetchOptions?: Record<string, string>;\n    errorPassThrough?: boolean;\n\n    timeout?: number,\n};\n\nexport interface OnceBlockable {\n    once(eventName: \"block\", handler: () => void): void;\n}\n\nexport interface OncePollable {\n    once(eventName: \"poll\", handler: () => void): void;\n}\n\nexport type PollOptions = {\n    timeout?: number,\n    floor?: number,\n    ceiling?: number,\n    interval?: number,\n    retryLimit?: number,\n    onceBlock?: OnceBlockable\n    oncePoll?: OncePollable\n};\n\nexport type FetchJsonResponse = {\n    statusCode: number;\n    headers: { [ header: string ]: string };\n};\n\n\ntype Header = { key: string, value: string };\n\nfunction unpercent(value: string): Uint8Array {\n    return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {\n        return String.fromCharCode(parseInt(code, 16));\n    }));\n}\n\n// This API is still a work in progress; the future changes will likely be:\n// - ConnectionInfo => FetchDataRequest<T = any>\n// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }\n//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)\n// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T\n// For this reason, it should be considered internal until the API is finalized\nexport function _fetchData<T = Uint8Array>(connection: string | ConnectionInfo, body?: Uint8Array, processFunc?: (value: Uint8Array, response: FetchJsonResponse) => T): Promise<T> {\n\n    // How many times to retry in the event of a throttle\n    const attemptLimit = (typeof(connection) === \"object\" && connection.throttleLimit != null) ? connection.throttleLimit: 12;\n    logger.assertArgument((attemptLimit > 0 && (attemptLimit % 1) === 0),\n        \"invalid connection throttle limit\", \"connection.throttleLimit\", attemptLimit);\n\n    const throttleCallback = ((typeof(connection) === \"object\") ? connection.throttleCallback: null);\n    const throttleSlotInterval = ((typeof(connection) === \"object\" && typeof(connection.throttleSlotInterval) === \"number\") ? connection.throttleSlotInterval: 100);\n    logger.assertArgument((throttleSlotInterval > 0 && (throttleSlotInterval % 1) === 0),\n        \"invalid connection throttle slot interval\", \"connection.throttleSlotInterval\", throttleSlotInterval);\n\n    const errorPassThrough = ((typeof(connection) === \"object\") ? !!(connection.errorPassThrough): false);\n\n    const headers: { [key: string]: Header } = { };\n\n    let url: string = null;\n\n    // @TODO: Allow ConnectionInfo to override some of these values\n    const options: Options = {\n        method: \"GET\",\n    };\n\n    let allow304 = false;\n\n    let timeout = 2 * 60 * 1000;\n\n    if (typeof(connection) === \"string\") {\n        url = connection;\n\n    } else if (typeof(connection) === \"object\") {\n        if (connection == null || connection.url == null) {\n            logger.throwArgumentError(\"missing URL\", \"connection.url\", connection);\n        }\n\n        url = connection.url;\n\n        if (typeof(connection.timeout) === \"number\" && connection.timeout > 0) {\n            timeout = connection.timeout;\n        }\n\n        if (connection.headers) {\n            for (const key in connection.headers) {\n                headers[key.toLowerCase()] = { key: key, value: String(connection.headers[key]) };\n                if ([\"if-none-match\", \"if-modified-since\"].indexOf(key.toLowerCase()) >= 0) {\n                    allow304 = true;\n                }\n            }\n        }\n\n        options.allowGzip = !!connection.allowGzip;\n\n        if (connection.user != null && connection.password != null) {\n            if (url.substring(0, 6) !== \"https:\" && connection.allowInsecureAuthentication !== true) {\n                logger.throwError(\n                    \"basic authentication requires a secure https url\",\n                    Logger.errors.INVALID_ARGUMENT,\n                    { argument: \"url\", url: url, user: connection.user, password: \"[REDACTED]\" }\n                );\n            }\n\n            const authorization = connection.user + \":\" + connection.password;\n            headers[\"authorization\"] = {\n                key: \"Authorization\",\n                value: \"Basic \" + base64Encode(toUtf8Bytes(authorization))\n            };\n        }\n\n        if (connection.skipFetchSetup != null) {\n            options.skipFetchSetup = !!connection.skipFetchSetup;\n        }\n\n        if (connection.fetchOptions != null) {\n            options.fetchOptions = shallowCopy(connection.fetchOptions);\n        }\n    }\n\n    const reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\n    const dataMatch = ((url) ? url.match(reData): null);\n    if (dataMatch) {\n        try {\n            const response = {\n                statusCode: 200,\n                statusMessage: \"OK\",\n                headers: { \"content-type\": (dataMatch[1] || \"text/plain\")},\n                body: (dataMatch[2] ? base64Decode(dataMatch[3]): unpercent(dataMatch[3]))\n            };\n\n            let result: T = <T><unknown>response.body;\n            if (processFunc) {\n                result = processFunc(response.body, response);\n            }\n            return Promise.resolve(<T><unknown>result);\n\n        } catch (error) {\n            logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                body: bodyify(dataMatch[1], dataMatch[2]),\n                error: error,\n                requestBody: null,\n                requestMethod: \"GET\",\n                url: url\n            });\n        }\n    }\n\n    if (body) {\n        options.method = \"POST\";\n        options.body = body;\n        if (headers[\"content-type\"] == null) {\n            headers[\"content-type\"] = { key: \"Content-Type\", value: \"application/octet-stream\" };\n        }\n        if (headers[\"content-length\"] == null) {\n            headers[\"content-length\"] = { key: \"Content-Length\", value: String(body.length) };\n        }\n    }\n\n    const flatHeaders: { [ key: string ]: string } = { };\n    Object.keys(headers).forEach((key) => {\n        const header = headers[key];\n        flatHeaders[header.key] = header.value;\n    });\n    options.headers = flatHeaders;\n\n    const runningTimeout = (function() {\n        let timer: NodeJS.Timer = null;\n        const promise: Promise<never> = new Promise(function(resolve, reject) {\n            if (timeout) {\n                timer = setTimeout(() => {\n                    if (timer == null) { return; }\n                    timer = null;\n\n                    reject(logger.makeError(\"timeout\", Logger.errors.TIMEOUT, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        timeout: timeout,\n                        url: url\n                    }));\n                }, timeout);\n            }\n        });\n\n        const cancel = function() {\n            if (timer == null) { return; }\n            clearTimeout(timer);\n            timer = null;\n        }\n\n        return { promise, cancel };\n    })();\n\n    const runningFetch = (async function() {\n\n        for (let attempt = 0; attempt < attemptLimit; attempt++) {\n            let response: GetUrlResponse = null;\n\n            try {\n                response = await getUrl(url, options);\n\n                if (attempt < attemptLimit) {\n                    if (response.statusCode === 301 || response.statusCode === 302) {\n                        // Redirection; for now we only support absolute locataions\n                        const location = response.headers.location || \"\";\n                        if (options.method === \"GET\" && location.match(/^https:/)) {\n                            url = response.headers.location;\n                            continue;\n                        }\n\n                    } else if (response.statusCode === 429) {\n                        // Exponential back-off throttling\n                        let tryAgain = true;\n                        if (throttleCallback) {\n                            tryAgain = await throttleCallback(attempt, url);\n                        }\n\n                        if (tryAgain) {\n                            let stall = 0;\n\n                            const retryAfter = response.headers[\"retry-after\"];\n                            if (typeof(retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                                stall = parseInt(retryAfter) * 1000;\n                            } else {\n                                stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                            }\n\n                            //console.log(\"Stalling 429\");\n                            await staller(stall);\n                            continue;\n                        }\n                    }\n                }\n\n            } catch (error) {\n                response = (<any>error).response;\n                if (response == null) {\n                    runningTimeout.cancel();\n                    logger.throwError(\"missing response\", Logger.errors.SERVER_ERROR, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        serverError: error,\n                        url: url\n                    });\n                }\n            }\n\n\n            let body = response.body;\n\n            if (allow304 && response.statusCode === 304) {\n                body = null;\n            } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {\n                runningTimeout.cancel();\n                logger.throwError(\"bad response\", Logger.errors.SERVER_ERROR, {\n                    status: response.statusCode,\n                    headers: response.headers,\n                    body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"]: null)),\n                    requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                    requestMethod: options.method,\n                    url: url\n                });\n            }\n\n            if (processFunc) {\n                try {\n                    const result = await processFunc(body, response);\n                    runningTimeout.cancel();\n                    return result;\n\n                } catch (error) {\n                    // Allow the processFunc to trigger a throttle\n                    if (error.throttleRetry && attempt < attemptLimit) {\n                        let tryAgain = true;\n                        if (throttleCallback) {\n                            tryAgain = await throttleCallback(attempt, url);\n                        }\n\n                        if (tryAgain) {\n                            const timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                            //console.log(\"Stalling callback\");\n                            await staller(timeout);\n                            continue;\n                        }\n                    }\n\n                    runningTimeout.cancel();\n                    logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                        body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"]: null)),\n                        error: error,\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        url: url\n                    });\n                }\n            }\n\n            runningTimeout.cancel();\n\n            // If we had a processFunc, it either returned a T or threw above.\n            // The \"body\" is now a Uint8Array.\n            return <T>(<unknown>body);\n        }\n\n        return logger.throwError(\"failed response\", Logger.errors.SERVER_ERROR, {\n            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n            requestMethod: options.method,\n            url: url\n        });\n    })();\n\n    return Promise.race([ runningTimeout.promise, runningFetch ]);\n}\n\nexport function fetchJson(connection: string | ConnectionInfo, json?: string, processFunc?: (value: any, response: FetchJsonResponse) => any): Promise<any> {\n    let processJsonFunc = (value: Uint8Array, response: FetchJsonResponse) => {\n        let result: any = null;\n        if (value != null) {\n            try {\n                result = JSON.parse(toUtf8String(value));\n            } catch (error) {\n                logger.throwError(\"invalid JSON\", Logger.errors.SERVER_ERROR, {\n                    body: value,\n                    error: error\n                });\n            }\n        }\n\n        if (processFunc) {\n            result = processFunc(result, response);\n        }\n\n        return result;\n    }\n\n    // If we have json to send, we must\n    // - add content-type of application/json (unless already overridden)\n    // - convert the json to bytes\n    let body: Uint8Array = null;\n    if (json != null) {\n        body = toUtf8Bytes(json);\n\n        // Create a connection with the content-type set for JSON\n        const updated: ConnectionInfo = (typeof(connection) === \"string\") ? ({ url: connection }): shallowCopy(connection);\n        if (updated.headers) {\n            const hasContentType = (Object.keys(updated.headers).filter((k) => (k.toLowerCase() === \"content-type\")).length) !== 0;\n            if (!hasContentType) {\n                updated.headers = shallowCopy(updated.headers);\n                updated.headers[\"content-type\"] = \"application/json\";\n            }\n        } else {\n            updated.headers = { \"content-type\": \"application/json\" };\n        }\n        connection = updated;\n    }\n\n    return _fetchData<any>(connection, body, processJsonFunc);\n}\n\nexport function poll<T>(func: () => Promise<T>, options?: PollOptions): Promise<T> {\n    if (!options) { options = {}; }\n    options = shallowCopy(options);\n    if (options.floor == null) { options.floor = 0; }\n    if (options.ceiling == null) { options.ceiling = 10000; }\n    if (options.interval == null) { options.interval = 250; }\n\n    return new Promise(function(resolve, reject) {\n\n        let timer: NodeJS.Timer = null;\n        let done: boolean = false;\n\n        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.\n        const cancel = (): boolean => {\n            if (done) { return false; }\n            done = true;\n            if (timer) { clearTimeout(timer); }\n            return true;\n        };\n\n        if (options.timeout) {\n            timer = setTimeout(() => {\n                if (cancel()) { reject(new Error(\"timeout\")); }\n            }, options.timeout)\n        }\n\n        const retryLimit = options.retryLimit;\n\n        let attempt = 0;\n        function check() {\n            return func().then(function(result) {\n\n                // If we have a result, or are allowed null then we're done\n                if (result !== undefined) {\n                    if (cancel()) { resolve(result); }\n\n                } else if (options.oncePoll) {\n                    options.oncePoll.once(\"poll\", check);\n\n                } else if (options.onceBlock) {\n                    options.onceBlock.once(\"block\", check);\n\n                // Otherwise, exponential back-off (up to 10s) our next request\n                } else if (!done) {\n                    attempt++;\n                    if (attempt > retryLimit) {\n                        if (cancel()) { reject(new Error(\"retry limit reached\")); }\n                        return;\n                    }\n\n                    let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                    if (timeout < options.floor) { timeout = options.floor; }\n                    if (timeout > options.ceiling) { timeout = options.ceiling; }\n\n                    setTimeout(check, timeout);\n                }\n\n                return null;\n            }, function(error) {\n                if (cancel()) { reject(error); }\n            });\n        }\n        check();\n    });\n}\n\n","/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nexport class BaseX {\n    readonly alphabet: string;\n    readonly base: number;\n\n    _alphabetMap: { [ character: string ]: number };\n    _leader: string;\n\n    constructor(alphabet: string) {\n        defineReadOnly(this, \"alphabet\", alphabet);\n        defineReadOnly(this, \"base\", alphabet.length);\n\n        defineReadOnly(this, \"_alphabetMap\", { });\n        defineReadOnly(this, \"_leader\", alphabet.charAt(0));\n\n        // pre-compute lookup table\n        for (let i = 0; i < alphabet.length; i++) {\n            this._alphabetMap[alphabet.charAt(i)] = i;\n        }\n    }\n\n    encode(value: BytesLike): string {\n        let source = arrayify(value);\n\n        if (source.length === 0) { return \"\"; }\n\n        let digits = [ 0 ]\n        for (let i = 0; i < source.length; ++i) {\n            let carry = source[i];\n            for (let j = 0; j < digits.length; ++j) {\n                carry += digits[j] << 8;\n                digits[j] = carry % this.base;\n                carry = (carry / this.base) | 0;\n            }\n\n            while (carry > 0) {\n                digits.push(carry % this.base);\n                carry = (carry / this.base) | 0;\n            }\n        }\n\n        let string = \"\"\n\n        // deal with leading zeros\n        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n            string += this._leader;\n        }\n\n        // convert digits to a string\n        for (let q = digits.length - 1; q >= 0; --q) {\n            string += this.alphabet[digits[q]];\n        }\n\n        return string;\n    }\n\n    decode(value: string): Uint8Array {\n        if (typeof(value) !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n\n        let bytes: Array<number> = [];\n        if (value.length === 0) { return new Uint8Array(bytes); }\n\n        bytes.push(0);\n        for (let i = 0; i < value.length; i++) {\n            let byte = this._alphabetMap[value[i]];\n\n            if (byte === undefined) {\n                throw new Error(\"Non-base\" + this.base + \" character\");\n            }\n\n            let carry = byte;\n            for (let j = 0; j < bytes.length; ++j) {\n                carry += bytes[j] * this.base;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n\n            while (carry > 0) {\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n\n        // deal with leading zeros\n        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n            bytes.push(0)\n        }\n\n        return arrayify(new Uint8Array(bytes.reverse()))\n    }\n}\n\nconst Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nconst Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\n\nexport { Base32, Base58 };\n\n//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n","/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\n\nexport type Numbers = Uint8Array | Array<number>;\nexport type NextFunc = (...args: Array<any>) => number;\n\n// https://github.com/behnammodi/polyfill/blob/master/array.polyfill.js\nfunction flat(array: Array<any>, depth?: number): Array<any> {\n    if (depth == null) { depth = 1; }\n    const result: Array<any> = [];\n\n    const forEach = result.forEach;\n\n    const flatDeep = function (arr: Array<any>, depth: number) {\n        forEach.call(arr, function (val: any) {\n            if (depth > 0 && Array.isArray(val)) {\n                flatDeep(val, depth - 1);\n            } else {\n               result.push(val);\n            }\n        });\n    };\n\n    flatDeep(array, depth);\n    return result;\n}\n\nfunction fromEntries<T extends string | number | symbol = string | number | symbol, U = any>(array: Array<[T, U]>): Record<T, U> {\n    const result: Record<T, U> = <Record<T, U>>{ };\n    for (let i = 0; i < array.length; i++) {\n        const value = array[i];\n        result[value[0]] = value[1];\n    }\n    return result;\n}\n\nexport function decode_arithmetic(bytes: Numbers): Array<number> {\n\tlet pos = 0;\n\tfunction u16() { return (bytes[pos++] << 8) | bytes[pos++]; }\n\t\n\t// decode the frequency table\n\tlet symbol_count = u16();\n\tlet total = 1;\n\tlet acc = [0, 1]; // first symbol has frequency 1\n\tfor (let i = 1; i < symbol_count; i++) {\n\t\tacc.push(total += u16());\n\t}\n\n\t// skip the sized-payload that the last 3 symbols index into\n\tlet skip = u16();\n\tlet pos_payload = pos;\n\tpos += skip;\n\n\tlet read_width = 0;\n\tlet read_buffer = 0; \n\tfunction read_bit() {\n\t\tif (read_width == 0) {\n\t\t\t// this will read beyond end of buffer\n\t\t\t// but (undefined|0) => zero pad\n\t\t\tread_buffer = (read_buffer << 8) | bytes[pos++];\n\t\t\tread_width = 8;\n\t\t}\n\t\treturn (read_buffer >> --read_width) & 1;\n\t}\n\n\tconst N = 31;\n\tconst FULL = 2**N;\n\tconst HALF = FULL >>> 1;\n\tconst QRTR = HALF >> 1;\n\tconst MASK = FULL - 1;\n\n\t// fill register\n\tlet register = 0;\n\tfor (let i = 0; i < N; i++) register = (register << 1) | read_bit();\n\n\tlet symbols = [];\n\tlet low = 0;\n\tlet range = FULL; // treat like a float\n\twhile (true) {\n\t\tlet value = Math.floor((((register - low + 1) * total) - 1) / range);\n\t\tlet start = 0;\n\t\tlet end = symbol_count;\n\t\twhile (end - start > 1) { // binary search\n\t\t\tlet mid = (start + end) >>> 1;\n\t\t\tif (value < acc[mid]) {\n\t\t\t\tend = mid;\n\t\t\t} else {\n\t\t\t\tstart = mid;\n\t\t\t}\n\t\t}\n\t\tif (start == 0) break; // first symbol is end mark\n\t\tsymbols.push(start);\n\t\tlet a = low + Math.floor(range * acc[start]   / total);\n\t\tlet b = low + Math.floor(range * acc[start+1] / total) - 1\n\t\twhile (((a ^ b) & HALF) == 0) {\n\t\t\tregister = (register << 1) & MASK | read_bit();\n\t\t\ta = (a << 1) & MASK;\n\t\t\tb = (b << 1) & MASK | 1;\n\t\t}\n\t\twhile (a & ~b & QRTR) {\n\t\t\tregister = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();\n\t\t\ta = (a << 1) ^ HALF;\n\t\t\tb = ((b ^ HALF) << 1) | HALF | 1;\n\t\t}\n\t\tlow = a;\n\t\trange = 1 + b - a;\n\t}\n\tlet offset = symbol_count - 4;\n\treturn symbols.map(x => { // index into payload\n\t\tswitch (x - offset) {\n\t\t\tcase 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);\n\t\t\tcase 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);\n\t\t\tcase 1: return offset + bytes[pos_payload++];\n\t\t\tdefault: return x - 1;\n\t\t}\n\t});\n}\t\n\n\n// returns an iterator which returns the next symbol\nexport function read_payload(v: Numbers): NextFunc {\n\tlet pos = 0;\n\treturn () => v[pos++];\n}\nexport function read_compressed_payload(bytes: Numbers): NextFunc {\n\treturn read_payload(decode_arithmetic(bytes));\n}\n\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nexport function signed(i: number): number { \n\treturn (i & 1) ? (~i >> 1) : (i >> 1);\n}\n\nfunction read_counts(n: number, next: NextFunc): Array<number> {\n\tlet v = Array(n);\n\tfor (let i = 0; i < n; i++) v[i] = 1 + next();\n\treturn v;\n}\n\nfunction read_ascending(n: number, next: NextFunc): Array<number> {\n\tlet v = Array(n);\n\tfor (let i = 0, x = -1; i < n; i++) v[i] = x += 1 + next();\n\treturn v;\n}\n\nfunction read_deltas(n: number, next: NextFunc): Array<number> {\n\tlet v = Array(n);\n\tfor (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());\n\treturn v;\n}\n\nexport function read_member_array(next: NextFunc, lookup?: Record<number, number>) {\n    let v = read_ascending(next(), next);\n    let n = next();\n    let vX = read_ascending(n, next);\n    let vN = read_counts(n, next);\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < vN[i]; j++) {\n            v.push(vX[i] + j);\n        }\n    }\n    return lookup ? v.map(x => lookup[x]) : v;\n}\n\n// returns array of \n// [x, ys] => single replacement rule\n// [x, ys, n, dx, dx] => linear map\nexport function read_mapped_map(next: NextFunc): Record<number, Array<number>> {\n\tlet ret = [];\n\twhile (true) {\n\t\tlet w = next();\n\t\tif (w == 0) break;\n\t\tret.push(read_linear_table(w, next));\n\t}\n\twhile (true) {\n\t\tlet w = next() - 1;\n\t\tif (w < 0) break;\n\t\tret.push(read_replacement_table(w, next));\n\t}\n\treturn fromEntries<number, Array<number>>(flat(ret));\n}\n\nexport function read_zero_terminated_array(next: NextFunc): Array<number> {\n\tlet v = [];\n\twhile (true) {\n\t\tlet i = next();\n\t\tif (i == 0) break;\n\t\tv.push(i);\n\t}\n\treturn v;\n}\n\nfunction read_transposed(n: number, w: number, next: NextFunc): Array<Array<number>> {\n    let m = Array(n).fill(undefined).map(() => []);\n    for (let i = 0; i < w; i++) {\n        read_deltas(n, next).forEach((x, j) => m[j].push(x));\n    }\n    return m;\n}\n\n\nfunction read_linear_table(w: number, next: NextFunc): Array<Array<number | Array<number>>> {\n\tlet dx = 1 + next();\n\tlet dy = next();\n\tlet vN = read_zero_terminated_array(next);\n\tlet m = read_transposed(vN.length, 1+w, next);\n\treturn flat(m.map((v, i) => {\n\t  const x = v[0], ys = v.slice(1);\n\t\t//let [x, ...ys] = v;\n\t\t//return Array(vN[i]).fill().map((_, j) => {\n\t\treturn Array(vN[i]).fill(undefined).map((_, j) => {\n\t\t\tlet j_dy = j * dy;\n\t\t\treturn [x + j * dx, ys.map(y => y + j_dy)];\n\t\t});\n\t}));\n}\n\nfunction read_replacement_table(w: number, next: NextFunc): Array<[ number, Array<number> ]> {\n\tlet n = 1 + next();\n\tlet m = read_transposed(n, 1+w, next);\n\treturn m.map(v => [v[0], v.slice(1)]);\n}\n\nexport type Branch = {\n    set: Set<number>;\n    node: Node;\n};\n\nexport type Node = {\n    branches: Array<Branch>;\n    valid: number;\n    fe0f: boolean;\n    save: boolean;\n    check: boolean;\n};\n\nexport function read_emoji_trie(next: NextFunc): Node {\n\tlet sorted = read_member_array(next).sort((a, b) => a - b);\n\treturn read();\n\tfunction read(): Node {\n\t\tlet branches = [];\n\t\twhile (true) {\n\t\t\tlet keys = read_member_array(next, sorted);\n\t\t\tif (keys.length == 0) break;\n\t\t\tbranches.push({set: new Set(keys), node: read()});\n\t\t}\n    branches.sort((a, b) => b.set.size - a.set.size); // sort by likelihood\n \t\tlet temp = next();\n \t\tlet valid = temp % 3;\n \t\ttemp = (temp / 3)|0;\n \t\tlet fe0f = !!(temp & 1);\n \t\ttemp >>= 1;\n \t\tlet save = temp == 1;\n \t\tlet check = temp == 2;\n \t\treturn {branches, valid, fe0f, save, check};\n\t}\n}\n","/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\n\nimport { toUtf8CodePoints } from \"@ethersproject/strings\";\n\nimport { getData } from './include.js';\nconst r = getData();\n\nimport {read_member_array, read_mapped_map, read_emoji_trie} from './decoder.js';\n\n// @TODO: This should be lazily loaded\n\nconst VALID = new Set(read_member_array(r));\nconst IGNORED = new Set(read_member_array(r));\nconst MAPPED = read_mapped_map(r);\nconst EMOJI_ROOT = read_emoji_trie(r);\n//const NFC_CHECK = new Set(read_member_array(r, Array.from(VALID.values()).sort((a, b) => a - b)));\n\n//const STOP = 0x2E;\nconst HYPHEN = 0x2D;\nconst UNDERSCORE = 0x5F;\n\nfunction explode_cp(name: string): Array<number> {\n    return toUtf8CodePoints(name);\n}\n\nfunction filter_fe0f(cps: Array<number>): Array<number> {\n    return cps.filter(cp => cp != 0xFE0F);\n}\n\nexport function ens_normalize_post_check(name: string): string {\n\tfor (let label of name.split('.')) {\n\t\tlet cps = explode_cp(label);\n\t\ttry {\n\t\t\tfor (let i = cps.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--) {\n\t\t\t\tif (cps[i] !== UNDERSCORE) {\n\t\t\t\t\tthrow new Error(`underscore only allowed at start`);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cps.length >= 4 && cps.every(cp => cp < 0x80) && cps[2] === HYPHEN && cps[3] === HYPHEN) {\n\t\t\t\tthrow new Error(`invalid label extension`);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tthrow new Error(`Invalid label \"${label}\": ${err.message}`);\n\t\t}\n\t}\n\treturn name;\n}\n\nexport function ens_normalize(name: string): string {\n\treturn ens_normalize_post_check(normalize(name, filter_fe0f));\n}\n\nfunction normalize(name: string, emoji_filter: (a: Array<number>) => Array<number>): string {\n\tlet input = explode_cp(name).reverse(); // flip for pop\n\tlet output = [];\n\twhile (input.length) {\t\t\n\t\tlet emoji = consume_emoji_reversed(input);\n\t\tif (emoji) {\n\t\t\toutput.push(...emoji_filter(emoji));\n\t\t\tcontinue;\n\t\t}\n\t\tlet cp = input.pop();\n\t\tif (VALID.has(cp)) {\n\t\t\toutput.push(cp);\n\t\t\tcontinue;\n\t\t} \n\t\tif (IGNORED.has(cp)) {\n\t\t\tcontinue;\n\t\t}\n\t\tlet cps = MAPPED[cp];\n\t\tif (cps) {\n\t\t\toutput.push(...cps);\n\t\t\tcontinue;\n\t\t}\n\t\tthrow new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);\n\t}\n\treturn ens_normalize_post_check(nfc(String.fromCodePoint(...output)));\n}\n\nfunction nfc(s: string): string {\n    return s.normalize('NFC');\n}\n\nfunction consume_emoji_reversed(cps: Array<number>, eaten?: Array<number>) {\n\tlet node = EMOJI_ROOT;\n\tlet emoji;\n\tlet saved;\n\tlet stack = [];\n\tlet pos = cps.length;\n\tif (eaten) eaten.length = 0; // clear input buffer (if needed)\n\twhile (pos) {\n\t\tlet cp = cps[--pos];\n\t\tnode = node.branches.find(x => x.set.has(cp))?.node;\n\t\tif (!node) break;\n\t\tif (node.save) { // remember\n\t\t\tsaved = cp;\n\t\t} else if (node.check) { // check exclusion\n\t\t\tif (cp === saved) break;\n\t\t}\n\t\tstack.push(cp);\n\t\tif (node.fe0f) {\n\t\t\tstack.push(0xFE0F);\n\t\t\tif (pos > 0 && cps[pos - 1] == 0xFE0F) pos--; // consume optional FE0F\n\t\t}\n\t\tif (node.valid) { // this is a valid emoji (so far)\n\t\t\temoji = stack.slice(); // copy stack\n\t\t\tif (node.valid == 2) emoji.splice(1, 1); // delete FE0F at position 1 (RGI ZWJ don't follow spec!)\n\t\t\tif (eaten) eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)\n\t\t\tcps.length = pos; // truncate\n\t\t}\n\t}\n\treturn emoji;\n}\n","/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\n\nimport { decode } from \"@ethersproject/base64\";\n\nimport {read_compressed_payload} from './decoder.js';\n\nexport function getData(): () => number {\n    return read_compressed_payload(decode('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'));\n}\n\n","import { concat, hexlify } from \"@ethersproject/bytes\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { ens_normalize } from \"./ens-normalize/lib\";\n\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\n\nfunction checkComponent(comp: Uint8Array): Uint8Array {\n    if (comp.length === 0) { throw new Error(\"invalid ENS name; empty component\"); }\n    return comp;\n}\n\nfunction ensNameSplit(name: string): Array<Uint8Array> {\n    const bytes = toUtf8Bytes(ens_normalize(name));\n    const comps: Array<Uint8Array> = [ ];\n\n    if (name.length === 0) { return comps; }\n\n    let last = 0;\n    for (let i = 0; i < bytes.length; i++) {\n        const d = bytes[i];\n\n        // A separator (i.e. \".\"); copy this component\n        if (d === 0x2e) {\n            comps.push(checkComponent(bytes.slice(last, i)));\n            last = i + 1;\n        }\n    }\n\n    // There was a stray separator at the end of the name\n    if (last >= bytes.length) { throw new Error(\"invalid ENS name; empty component\"); }\n\n    comps.push(checkComponent(bytes.slice(last)));\n    return comps;\n}\n\nexport function ensNormalize(name: string): string {\n    return ensNameSplit(name).map((comp) => toUtf8String(comp)).join(\".\");\n}\n\nexport function isValidName(name: string): boolean {\n    try {\n        return (ensNameSplit(name).length !== 0);\n    } catch (error) { }\n    return false;\n}\n\nexport function namehash(name: string): string {\n    /* istanbul ignore if */\n    if (typeof(name) !== \"string\") {\n        logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n    }\n\n    let result: string | Uint8Array = Zeros;\n\n    const comps = ensNameSplit(name);\n    while (comps.length) {\n        result = keccak256(concat([result, keccak256(comps.pop())]));\n    }\n\n    return hexlify(result);\n}\n\nexport function dnsEncode(name: string): string {\n    return hexlify(concat(ensNameSplit(name).map((comp) => {\n        // DNS does not allow components over 63 bytes in length\n        if (comp.length > 63) {\n            throw new Error(\"invalid DNS encoded entry; length exceeds 63 bytes\");\n        }\n\n        const bytes = new Uint8Array(comp.length + 1);\n        bytes.set(comp, 1);\n        bytes[0] = bytes.length - 1;\n        return bytes;\n\n    }))) + \"00\";\n}\n","export const version = \"networks/5.7.1\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Network, Networkish } from \"./types\";\n\nexport {\n    Network,\n    Networkish\n};\n\ntype DefaultProviderFunc = (providers: any, options?: any) => any;\n\ninterface Renetworkable extends DefaultProviderFunc {\n    renetwork: (network: Network) => DefaultProviderFunc;\n};\n\nfunction isRenetworkable(value: any): value is Renetworkable {\n    return (value && typeof(value.renetwork) === \"function\");\n}\n\nfunction ethDefaultProvider(network: string | Network): Renetworkable {\n    const func = function(providers: any, options?: any): any {\n        if (options == null) { options = { }; }\n        const providerList: Array<any> = [];\n\n        if (providers.InfuraProvider && options.infura !== \"-\") {\n            try {\n                providerList.push(new providers.InfuraProvider(network, options.infura));\n            } catch(error) { }\n        }\n\n        if (providers.EtherscanProvider && options.etherscan !== \"-\") {\n            try {\n                providerList.push(new providers.EtherscanProvider(network, options.etherscan));\n            } catch(error) { }\n        }\n\n        if (providers.AlchemyProvider && options.alchemy !== \"-\") {\n            try {\n                providerList.push(new providers.AlchemyProvider(network, options.alchemy));\n            } catch(error) { }\n        }\n\n        if (providers.PocketProvider && options.pocket !== \"-\") {\n            // These networks are currently faulty on Pocket as their\n            // network does not handle the Berlin hardfork, which is\n            // live on these ones.\n            // @TODO: This goes away once Pocket has upgraded their nodes\n            const skip = [ \"goerli\", \"ropsten\", \"rinkeby\", \"sepolia\" ];\n            try {\n                const provider = new providers.PocketProvider(network, options.pocket);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            } catch(error) { }\n        }\n\n        if (providers.CloudflareProvider && options.cloudflare !== \"-\") {\n            try {\n                providerList.push(new providers.CloudflareProvider(network));\n            } catch(error) { }\n        }\n\n        if (providers.AnkrProvider && options.ankr !== \"-\") {\n            try {\n                const skip = [ \"ropsten\" ];\n                const provider = new providers.AnkrProvider(network, options.ankr);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            } catch(error) { }\n        }\n\n        if (providerList.length === 0) { return null; }\n\n        if (providers.FallbackProvider) {\n            let quorum = 1;\n            if (options.quorum != null) {\n                quorum = options.quorum;\n            } else if (network === \"homestead\") {\n                quorum = 2;\n            }\n            return new providers.FallbackProvider(providerList, quorum);\n        }\n\n        return providerList[0];\n    };\n\n    func.renetwork = function(network: Network) {\n        return ethDefaultProvider(network);\n    };\n\n    return func;\n}\n\nfunction etcDefaultProvider(url: string, network: string | Network): Renetworkable {\n    const func = function(providers: any, options?: any): any {\n        if (providers.JsonRpcProvider) {\n            return new providers.JsonRpcProvider(url, network);\n        }\n\n        return null;\n    };\n\n    func.renetwork = function(network: Network) {\n        return etcDefaultProvider(url, network);\n    };\n\n    return func;\n}\n\nconst homestead: Network = {\n    chainId: 1,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"homestead\",\n    _defaultProvider: ethDefaultProvider(\"homestead\")\n};\n\nconst ropsten: Network = {\n    chainId: 3,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"ropsten\",\n    _defaultProvider: ethDefaultProvider(\"ropsten\")\n};\n\nconst classicMordor: Network = {\n    chainId: 63,\n    name: \"classicMordor\",\n    _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/mordor\", \"classicMordor\")\n};\n\n// See: https://chainlist.org\nconst networks: { [name: string]: Network } = {\n    unspecified: { chainId: 0, name: \"unspecified\" },\n\n    homestead: homestead,\n    mainnet: homestead,\n\n    morden: { chainId: 2, name: \"morden\" },\n\n    ropsten: ropsten,\n    testnet: ropsten,\n\n    rinkeby: {\n        chainId: 4,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"rinkeby\",\n        _defaultProvider: ethDefaultProvider(\"rinkeby\")\n    },\n\n    kovan: {\n        chainId: 42,\n        name: \"kovan\",\n        _defaultProvider: ethDefaultProvider(\"kovan\")\n    },\n\n    goerli: {\n        chainId: 5,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"goerli\",\n        _defaultProvider: ethDefaultProvider(\"goerli\")\n    },\n\n    kintsugi: { chainId: 1337702, name: \"kintsugi\" },\n\n    sepolia: {\n        chainId: 11155111,\n        name: \"sepolia\",\n        _defaultProvider: ethDefaultProvider(\"sepolia\")\n    },\n\n\n    // ETC (See: #351)\n    classic: {\n        chainId: 61,\n        name: \"classic\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/etc\", \"classic\")\n    },\n\n    classicMorden: { chainId: 62, name: \"classicMorden\" },\n\n    classicMordor: classicMordor,\n    classicTestnet: classicMordor,\n\n    classicKotti: {\n        chainId: 6,\n        name: \"classicKotti\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/kotti\", \"classicKotti\")\n    },\n\n    xdai: { chainId: 100, name: \"xdai\" },\n\n    matic: {\n        chainId: 137,\n        name: \"matic\",\n        _defaultProvider: ethDefaultProvider(\"matic\")\n    },\n    maticmum: { chainId: 80001, name: \"maticmum\" },\n\n    optimism: {\n        chainId: 10,\n        name: \"optimism\",\n        _defaultProvider: ethDefaultProvider(\"optimism\")\n    },\n    \"optimism-kovan\": { chainId: 69, name: \"optimism-kovan\" },\n    \"optimism-goerli\": { chainId: 420, name: \"optimism-goerli\" },\n\n    arbitrum: { chainId: 42161, name: \"arbitrum\" },\n    \"arbitrum-rinkeby\": { chainId: 421611, name: \"arbitrum-rinkeby\" },\n    \"arbitrum-goerli\": { chainId: 421613, name: \"arbitrum-goerli\" },\n\n    bnb: { chainId: 56, name: \"bnb\" },\n    bnbt: { chainId: 97, name: \"bnbt\" },\n}\n\n/**\n *  getNetwork\n *\n *  Converts a named common networks or chain ID (network ID) to a Network\n *  and verifies a network is a valid Network..\n */\nexport function getNetwork(network: Networkish): Network {\n    // No network (null)\n    if (network == null) { return null; }\n\n    if (typeof(network) === \"number\") {\n        for (const name in networks) {\n            const standard = networks[name];\n            if (standard.chainId === network) {\n                return {\n                    name: standard.name,\n                    chainId: standard.chainId,\n                    ensAddress: (standard.ensAddress || null),\n                    _defaultProvider: (standard._defaultProvider || null)\n                };\n            }\n        }\n\n        return {\n            chainId: network,\n            name: \"unknown\"\n        };\n    }\n\n    if (typeof(network) === \"string\") {\n        const standard = networks[network];\n        if (standard == null) { return null; }\n        return {\n            name: standard.name,\n            chainId: standard.chainId,\n            ensAddress: standard.ensAddress,\n            _defaultProvider: (standard._defaultProvider || null)\n        };\n    }\n\n    const standard  = networks[network.name];\n\n    // Not a standard network; check that it is a valid network in general\n    if (!standard) {\n        if (typeof(network.chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid network chainId\", \"network\", network);\n        }\n        return network;\n    }\n\n    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)\n    if (network.chainId !== 0 && network.chainId !== standard.chainId) {\n        logger.throwArgumentError(\"network chainId mismatch\", \"network\", network);\n    }\n\n    // @TODO: In the next major version add an attach function to a defaultProvider\n    // class and move the _defaultProvider internal to this file (extend Network)\n    let defaultProvider: DefaultProviderFunc = network._defaultProvider || null;\n    if (defaultProvider == null && standard._defaultProvider) {\n        if (isRenetworkable(standard._defaultProvider)) {\n            defaultProvider = standard._defaultProvider.renetwork(network);\n        } else {\n            defaultProvider = standard._defaultProvider;\n        }\n    }\n\n    // Standard Network (allow overriding the ENS address)\n    return {\n        name: network.name,\n        chainId: standard.chainId,\n        ensAddress: (network.ensAddress || standard.ensAddress || null),\n        _defaultProvider: defaultProvider\n    };\n}\n","\"use strict\";\n\nimport hash from \"hash.js\";\n//const _ripemd160 = _hash.ripemd160;\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { SupportedAlgorithm } from \"./types\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function ripemd160(data: BytesLike): string {\n    return \"0x\" + (hash.ripemd160().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha256(data: BytesLike): string {\n    return \"0x\" + (hash.sha256().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha512(data: BytesLike): string {\n    return \"0x\" + (hash.sha512().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function computeHmac(algorithm: SupportedAlgorithm, key: BytesLike, data: BytesLike): string {\n    if (!SupportedAlgorithm[algorithm]) {\n        logger.throwError(\"unsupported algorithm \" + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n\n    return \"0x\" + hash.hmac((<any>hash)[algorithm], arrayify(key)).update(arrayify(data)).digest(\"hex\");\n}\n\n","export const version = \"sha2/5.7.0\";\n","\"use strict\";\n\nimport { Block, TransactionReceipt, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexDataLength, hexDataSlice, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { AccessList, accessListify, parse as parseTransaction } from \"@ethersproject/transactions\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport type FormatFunc = (value: any) => any;\n\nexport type FormatFuncs = { [ key: string ]: FormatFunc };\n\nexport type Formats = {\n    transaction: FormatFuncs,\n    transactionRequest: FormatFuncs,\n    receipt: FormatFuncs,\n    receiptLog: FormatFuncs,\n    block: FormatFuncs,\n    blockWithTransactions: FormatFuncs,\n    filter: FormatFuncs,\n    filterLog: FormatFuncs,\n};\n\nexport class Formatter {\n    readonly formats: Formats;\n\n    constructor() {\n        this.formats = this.getDefaultFormats();\n    }\n\n    getDefaultFormats(): Formats {\n        const formats: Formats = <Formats>({ });\n\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n\n        const strictData = (v: any) => { return this.data(v, true); };\n\n        formats.transaction = {\n            hash: hash,\n\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n\n            confirmations: Formatter.allowNull(number, null),\n\n            from: address,\n\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n\n            creates: Formatter.allowNull(address, null),\n\n            raw: Formatter.allowNull(data),\n        };\n\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n        };\n\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash,\n        };\n\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),// @TODO: should this be data?\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n\n        formats.block = {\n            hash: Formatter.allowNull(hash),\n            parentHash: hash,\n            number: number,\n\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n\n            miner: Formatter.allowNull(address),\n            extraData: data,\n\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n\n        formats.blockWithTransactions = shallowCopy(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n        };\n\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n\n            topics: Formatter.arrayOf(hash),\n\n            transactionHash: hash,\n            logIndex: number,\n        };\n\n        return formats;\n    }\n\n    accessList(accessList: Array<any>): AccessList {\n        return accessListify(accessList || []);\n    }\n\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number: any): number {\n        if (number === \"0x\") { return 0; }\n        return BigNumber.from(number).toNumber();\n    }\n\n    type(number: any): number {\n        if (number === \"0x\" || number == null) { return 0; }\n        return BigNumber.from(number).toNumber();\n    }\n\n    // Strict! Used on input.\n    bigNumber(value: any): BigNumber {\n        return BigNumber.from(value);\n    }\n\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value: any): boolean {\n        if (typeof(value) === \"boolean\") { return value; }\n        if (typeof(value) === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") { return true; }\n            if (value === \"false\") { return false; }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n\n    hex(value: any, strict?: boolean): string {\n        if (typeof(value) === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n            if (isHexString(value)) {\n               return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n\n    data(value: any, strict?: boolean): string {\n        const result = this.hex(value, strict);\n        if ((result.length % 2) !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n\n    // Requires an address\n    // Strict! Used on input.\n    address(value: any): string {\n        return getAddress(value);\n    }\n\n    callAddress(value: any): string {\n        if (!isHexString(value, 32)) { return null; }\n        const address = getAddress(hexDataSlice(value, 12));\n        return (address === AddressZero) ? null: address;\n    }\n\n    contractAddress(value: any): string {\n        return getContractAddress(value);\n    }\n\n    // Strict! Used on input.\n    blockTag(blockTag: any): string {\n        if (blockTag == null) { return \"latest\"; }\n\n        if (blockTag === \"earliest\") { return \"0x0\"; }\n\n        switch (blockTag) {\n            case \"earliest\": return \"0x0\";\n            case \"latest\": case \"pending\": case \"safe\": case \"finalized\":\n                return blockTag;\n        }\n\n        if (typeof(blockTag) === \"number\" || isHexString(blockTag)) {\n            return hexValue(<number | string>blockTag);\n        }\n\n        throw new Error(\"invalid blockTag\");\n    }\n\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value: any, strict?: boolean): string {\n        const result = this.hex(value, strict);\n        if (hexDataLength(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value: any): number {\n        if (value == null) { return null; }\n\n        const v = BigNumber.from(value);\n\n        try {\n            return v.toNumber();\n        } catch (error) { }\n\n       return null;\n    }\n\n    uint256(value: any): string {\n        if (!isHexString(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return hexZeroPad(value, 32);\n    }\n\n    _block(value: any, format: any): Block {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = (value._difficulty != null) ? value._difficulty: value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = ((difficulty == null) ? null: BigNumber.from(difficulty));\n        return result;\n    }\n\n    block(value: any): Block {\n        return this._block(value, this.formats.block);\n    }\n\n    blockWithTransactions(value: any): Block {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n\n    // Strict! Used on input.\n    transactionRequest(value: any): any {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n\n    transactionResponse(transaction: any): TransactionResponse {\n\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n\n        if ((transaction.type === 1 || transaction.type === 2)&& transaction.accessList == null) {\n            transaction.accessList = [ ];\n        }\n\n        const result: TransactionResponse = Formatter.check(this.formats.transaction, transaction);\n\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n\n            result.chainId = chainId;\n\n        } else {\n            let chainId = transaction.networkId;\n\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n\n            if (typeof(chainId) !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) { chainId = 0; }\n                chainId = parseInt(chainId);\n            }\n\n            if (typeof(chainId) !== \"number\") { chainId = 0; }\n\n            result.chainId = chainId;\n        }\n\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n\n        return result;\n    }\n\n    transaction(value: any): any {\n        return parseTransaction(value);\n    }\n\n    receiptLog(value: any): any {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n\n    receipt(value: any): TransactionReceipt {\n        const result: TransactionReceipt = Formatter.check(this.formats.receipt, value);\n\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && (result.status !== value)) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n                    }\n                    result.status = value;\n                    delete result.root;\n                } else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            } else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n\n        return result;\n    }\n\n    topics(value: any): any {\n        if (Array.isArray(value)) {\n            return value.map((v) => this.topics(v));\n\n        } else if (value != null) {\n            return this.hash(value, true);\n        }\n\n        return null;\n    }\n\n    filter(value: any): any {\n        return Formatter.check(this.formats.filter, value);\n    }\n\n    filterLog(value: any): any {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n\n    static check(format: { [ name: string ]: FormatFunc }, object: any): any {\n        const result: any = {};\n        for (const key in format) {\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) { result[key] = value; }\n            } catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n\n    // if value is null-ish, nullValue is returned\n    static allowNull(format: FormatFunc, nullValue?: any): FormatFunc {\n        return (function(value: any) {\n            if (value == null) { return nullValue; }\n            return format(value);\n        });\n    }\n\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format: FormatFunc, replaceValue: any): FormatFunc {\n        return (function(value: any) {\n            if (!value) { return replaceValue; }\n            return format(value);\n        });\n    }\n\n    // Requires an Array satisfying check\n    static arrayOf(format: FormatFunc): FormatFunc {\n        return (function(array: any): Array<any> {\n            if (!Array.isArray(array)) { throw new Error(\"not an array\"); }\n\n            const result: any = [];\n\n            array.forEach(function(value) {\n                result.push(format(value));\n            });\n\n            return result;\n        });\n    }\n}\n\nexport interface CommunityResourcable {\n    isCommunityResource(): boolean;\n}\n\nexport function isCommunityResourcable(value: any): value is CommunityResourcable {\n    return (value && typeof(value.isCommunityResource) === \"function\");\n}\n\nexport function isCommunityResource(value: any): boolean {\n    return (isCommunityResourcable(value) && value.isCommunityResource());\n}\n\n// Show the throttle message only once\nlet throttleMessage = false;\nexport function showThrottleMessage() {\n    if (throttleMessage) { return; }\n    throttleMessage = true;\n\n    console.log(\"========= NOTICE =========\")\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n}\n\n","export const AddressZero = \"0x0000000000000000000000000000000000000000\";\n\n","\"use strict\";\n\nimport {\n    Block, BlockTag, BlockWithTransactions, EventType, Filter, FilterByBlockHash, ForkEvent,\n    Listener, Log, Provider, TransactionReceipt, TransactionRequest, TransactionResponse\n} from \"@ethersproject/abstract-provider\";\nimport { encode as base64Encode } from \"@ethersproject/base64\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, concat, hexConcat, hexDataLength, hexDataSlice, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { HashZero } from \"@ethersproject/constants\";\nimport { dnsEncode, namehash } from \"@ethersproject/hash\";\nimport { getNetwork, Network, Networkish } from \"@ethersproject/networks\";\nimport { Deferrable, defineReadOnly, getStatic, resolveProperties } from \"@ethersproject/properties\";\nimport { Transaction } from \"@ethersproject/transactions\";\nimport { sha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\n\nimport bech32 from \"bech32\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Formatter } from \"./formatter\";\n\nconst MAX_CCIP_REDIRECTS = 10;\n\n//////////////////////////////\n// Event Serializeing\n\nfunction checkTopic(topic: string): string {\n     if (topic == null) { return \"null\"; }\n     if (hexDataLength(topic) !== 32) {\n         logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n     }\n     return topic.toLowerCase();\n}\n\nfunction serializeTopics(topics: Array<string | Array<string>>): string {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while (topics.length > 0 && topics[topics.length - 1] == null) { topics.pop(); }\n\n    return topics.map((topic) => {\n        if (Array.isArray(topic)) {\n\n            // Only track unique OR-topics\n            const unique: { [ topic: string ]: boolean } = { }\n            topic.forEach((topic) => {\n                unique[checkTopic(topic)] = true;\n            });\n\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n\n            return sorted.join(\"|\");\n\n        } else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\n\nfunction deserializeTopics(data: string): Array<string | Array<string>> {\n    if (data === \"\") { return [ ]; }\n\n    return data.split(/&/g).map((topic) => {\n        if (topic === \"\") { return [ ]; }\n\n        const comps = topic.split(\"|\").map((topic) => {\n            return ((topic === \"null\") ? null: topic);\n        });\n\n        return ((comps.length === 1) ? comps[0]: comps);\n    });\n}\n\nfunction getEventTag(eventName: EventType): string {\n    if (typeof(eventName) === \"string\") {\n        eventName = eventName.toLowerCase();\n\n        if (hexDataLength(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n\n    } else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n\n    } else if (ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n\n    } else if (eventName && typeof(eventName) === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n\n    throw new Error(\"invalid event - \" + eventName);\n}\n\n//////////////////////////////\n// Helper Object\n\nfunction getTime() {\n    return (new Date()).getTime();\n}\n\nfunction stall(duration: number): Promise<void> {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n\n//////////////////////////////\n// Provider Object\n\n\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\n\nconst PollableEvents = [ \"block\", \"network\", \"pending\", \"poll\" ];\n\nexport class Event {\n    readonly listener: Listener;\n    readonly once: boolean;\n    readonly tag: string;\n\n    _lastBlockNumber: number\n    _inflight: boolean;\n\n    constructor(tag: string, listener: Listener, once: boolean) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"listener\", listener);\n        defineReadOnly(this, \"once\", once);\n\n        this._lastBlockNumber = -2;\n        this._inflight = false;\n    }\n\n    get event(): EventType {\n        switch (this.type) {\n            case \"tx\":\n               return this.hash;\n            case \"filter\":\n               return this.filter;\n        }\n        return this.tag;\n    }\n\n    get type(): string {\n        return this.tag.split(\":\")[0]\n    }\n\n    get hash(): string {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") { return null; }\n        return comps[1];\n    }\n\n    get filter(): Filter {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") { return null; }\n        const address = comps[1];\n\n        const topics = deserializeTopics(comps[2]);\n        const filter: Filter = { };\n\n        if (topics.length > 0) { filter.topics = topics; }\n        if (address && address !== \"*\") { filter.address = address; }\n\n        return filter;\n    }\n\n    pollable(): boolean {\n        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n    }\n}\n\nexport interface EnsResolver {\n\n    // Name this Resolver is associated with\n    readonly name: string;\n\n    // The address of the resolver\n    readonly address: string;\n\n    // Multichain address resolution (also normal address resolution)\n    // See: https://eips.ethereum.org/EIPS/eip-2304\n    getAddress(coinType?: 60): Promise<null | string>\n\n    // Contenthash field\n    // See: https://eips.ethereum.org/EIPS/eip-1577\n    getContentHash(): Promise<null | string>;\n\n    // Storage of text records\n    // See: https://eips.ethereum.org/EIPS/eip-634\n    getText(key: string): Promise<null | string>;\n};\n\nexport interface EnsProvider {\n    resolveName(name: string): Promise<null | string>;\n    lookupAddress(address: string): Promise<null | string>;\n    getResolver(name: string): Promise<null | EnsResolver>;\n}\n\ntype CoinInfo = {\n    symbol: string,\n    ilk?: string,     // General family\n    prefix?: string,  // Bech32 prefix\n    p2pkh?: number,   // Pay-to-Public-Key-Hash Version\n    p2sh?: number,    // Pay-to-Script-Hash Version\n};\n\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos: { [ coinType: string ]: CoinInfo } = {\n    \"0\":   { symbol: \"btc\",  p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n    \"2\":   { symbol: \"ltc\",  p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n    \"3\":   { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n    \"60\":  { symbol: \"eth\",  ilk: \"eth\" },\n    \"61\":  { symbol: \"etc\",  ilk: \"eth\" },\n    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n};\n\nfunction bytes32ify(value: number): string {\n    return hexZeroPad(BigNumber.from(value).toHexString(), 32);\n}\n\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data: Uint8Array): string {\n    return Base58.encode(concat([ data, hexDataSlice(sha256(sha256(data)), 0, 4) ]));\n}\n\nexport interface Avatar {\n    url: string;\n    linkage: Array<{ type: string, content: string }>;\n}\n\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\n\nfunction _parseString(result: string, start: number): null | string {\n    try {\n        return toUtf8String(_parseBytes(result, start));\n    } catch(error) { }\n    return null;\n}\n\nfunction _parseBytes(result: string, start: number): null | string {\n    if (result === \"0x\") { return null; }\n\n    const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();\n    const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();\n\n    return hexDataSlice(result, offset + 32, offset + 32 + length);\n}\n\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link: string): string {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    } else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    } else {\n        logger.throwArgumentError(\"unsupported IPFS format\", \"link\", link);\n    }\n\n    return `https:/\\/gateway.ipfs.io/ipfs/${ link }`;\n}\n\nfunction numPad(value: number): Uint8Array {\n    const result = arrayify(value);\n    if (result.length > 32) { throw new Error(\"internal; should not happen\"); }\n\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\n\nfunction bytesPad(value: Uint8Array): Uint8Array {\n    if ((value.length % 32) === 0) { return value; }\n\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\n\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas: Array<BytesLike>) {\n    const result: Array<Uint8Array> = [ ];\n\n    let byteCount = 0;\n\n    // Add place-holders for pointers as we add items\n    for (let i = 0; i < datas.length; i++) {\n        result.push(null);\n        byteCount += 32;\n    }\n\n    for (let i = 0; i < datas.length; i++) {\n        const data = arrayify(datas[i]);\n\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n\n    return hexConcat(result);\n}\n\nexport class Resolver implements EnsResolver {\n    readonly provider: BaseProvider;\n\n    readonly name: string;\n    readonly address: string;\n\n    readonly _resolvedAddress: null | string;\n\n    // For EIP-2544 names, the ancestor that provided the resolver\n    _supportsEip2544: null | Promise<boolean>;\n\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider: BaseProvider, address: string, name: string, resolvedAddress?: string) {\n        defineReadOnly(this, \"provider\", provider);\n        defineReadOnly(this, \"name\", name);\n        defineReadOnly(this, \"address\", provider.formatter.address(address));\n        defineReadOnly(this, \"_resolvedAddress\", resolvedAddress);\n    }\n\n    supportsWildcard(): Promise<boolean> {\n        if (!this._supportsEip2544) {\n            // supportsInterface(bytes4 = selector(\"resolve(bytes,bytes)\"))\n            this._supportsEip2544 = this.provider.call({\n                to: this.address,\n                data: \"0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000\"\n            }).then((result) => {\n                return BigNumber.from(result).eq(1);\n            }).catch((error) => {\n                if (error.code === Logger.errors.CALL_EXCEPTION) { return false; }\n                // Rethrow the error: link is down, etc. Let future attempts retry.\n                this._supportsEip2544 = null;\n                throw error;\n            });\n        }\n\n        return this._supportsEip2544;\n    }\n\n    async _fetch(selector: string, parameters?: string): Promise<null | string> {\n\n        // e.g. keccak256(\"addr(bytes32,uint256)\")\n        const tx = {\n            to: this.address,\n            ccipReadEnabled: true,\n            data: hexConcat([ selector, namehash(this.name), (parameters || \"0x\") ])\n        };\n\n        // Wildcard support; use EIP-2544 to resolve the request\n        let parseBytes = false;\n        if (await this.supportsWildcard()) {\n            parseBytes = true;\n\n            // selector(\"resolve(bytes,bytes)\")\n            tx.data = hexConcat([ \"0x9061b923\", encodeBytes([ dnsEncode(this.name), tx.data ]) ]);\n        }\n\n        try {\n            let result = await this.provider.call(tx);\n            if ((arrayify(result).length % 32) === 4) {\n                logger.throwError(\"resolver threw error\", Logger.errors.CALL_EXCEPTION, {\n                    transaction: tx, data: result\n                });\n            }\n            if (parseBytes) { result = _parseBytes(result, 0); }\n            return result;\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n            throw error;\n        }\n    }\n\n    async _fetchBytes(selector: string, parameters?: string): Promise<null | string> {\n        const result = await this._fetch(selector, parameters);\n        if (result != null) { return _parseBytes(result, 0); }\n        return null;\n    }\n\n    _getAddress(coinType: number, hexBytes: string): string {\n        const coinInfo = coinInfos[String(coinType)];\n\n        if (coinInfo == null) {\n            logger.throwError(`unsupported coin type: ${ coinType }`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${ coinType })`\n            });\n        }\n\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n\n        const bytes = arrayify(hexBytes);\n\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([ [ coinInfo.p2pkh ], (\"0x\" + p2pkh[2]) ]));\n                }\n            }\n        }\n\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([ [ coinInfo.p2sh ], (\"0x\" + p2sh[2]) ]));\n                }\n            }\n        }\n\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            } else {\n                version = -1;\n            }\n\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32.toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32.encode(coinInfo.prefix, words);\n            }\n        }\n\n        return null;\n    }\n\n\n    async getAddress(coinType?: number): Promise<string> {\n        if (coinType == null) { coinType = 60; }\n\n        // If Ethereum, use the standard `addr(bytes32)`\n        if (coinType === 60) {\n            try {\n                // keccak256(\"addr(bytes32)\")\n                const result = await this._fetch(\"0x3b3b57de\");\n\n                // No address\n                if (result === \"0x\" || result === HashZero) { return null; }\n\n                return this.provider.formatter.callAddress(result);\n            } catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n                throw error;\n            }\n        }\n\n        // keccak256(\"addr(bytes32,uint256\")\n        const hexBytes = await this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n\n        // No address\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        // Compute the address\n        const address = this._getAddress(coinType, hexBytes);\n\n        if (address == null) {\n            logger.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${ coinType })`,\n                coinType: coinType,\n                data: hexBytes\n            });\n        }\n\n        return address;\n    }\n\n    async getAvatar(): Promise<null | Avatar> {\n        const linkage: Array<{ type: string, content: string }> = [ { type: \"name\", content: this.name } ];\n        try {\n            // test data for ricmoo.eth\n            //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n            const avatar = await this.getText(\"avatar\");\n            if (avatar == null) { return null; }\n\n            for (let i = 0; i < matchers.length; i++) {\n                const match = avatar.match(matchers[i]);\n                if (match == null) { continue; }\n\n                const scheme = match[1].toLowerCase();\n\n                switch (scheme) {\n                    case \"https\":\n                        linkage.push({ type: \"url\", content: avatar });\n                        return { linkage, url: avatar };\n\n                    case \"data\":\n                        linkage.push({ type: \"data\", content: avatar });\n                        return { linkage, url: avatar };\n\n                    case \"ipfs\":\n                        linkage.push({ type: \"ipfs\", content: avatar });\n                        return { linkage, url: getIpfsLink(avatar) };\n\n                    case \"erc721\":\n                    case \"erc1155\": {\n                        // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                        const selector = (scheme === \"erc721\") ? \"0xc87b56dd\": \"0x0e89341c\";\n                        linkage.push({ type: scheme, content: avatar });\n\n                        // The owner of this name\n                        const owner = (this._resolvedAddress || await this.getAddress());\n\n                        const comps = (match[2] || \"\").split(\"/\");\n                        if (comps.length !== 2) { return null; }\n\n                        const addr = await this.provider.formatter.address(comps[0]);\n                        const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);\n\n                        // Check that this account owns the token\n                        if (scheme === \"erc721\") {\n                            // ownerOf(uint256 tokenId)\n                            const tokenOwner = this.provider.formatter.callAddress(await this.provider.call({\n                                to: addr, data: hexConcat([ \"0x6352211e\", tokenId ])\n                            }));\n                            if (owner !== tokenOwner) { return null; }\n                            linkage.push({ type: \"owner\", content: tokenOwner });\n\n                        } else if (scheme === \"erc1155\") {\n                            // balanceOf(address owner, uint256 tokenId)\n                            const balance = BigNumber.from(await this.provider.call({\n                                to: addr, data: hexConcat([ \"0x00fdd58e\", hexZeroPad(owner, 32), tokenId ])\n                            }));\n                            if (balance.isZero()) { return null; }\n                            linkage.push({ type: \"balance\", content: balance.toString() });\n                        }\n\n                        // Call the token contract for the metadata URL\n                        const tx = {\n                            to: this.provider.formatter.address(comps[0]),\n                            data: hexConcat([ selector, tokenId ])\n                        };\n\n                        let metadataUrl = _parseString(await this.provider.call(tx), 0);\n                        if (metadataUrl == null) { return null; }\n                        linkage.push({ type: \"metadata-url-base\", content: metadataUrl });\n\n                        // ERC-1155 allows a generic {id} in the URL\n                        if (scheme === \"erc1155\") {\n                            metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                            linkage.push({ type: \"metadata-url-expanded\", content: metadataUrl });\n                        }\n\n                        // Transform IPFS metadata links\n                        if (metadataUrl.match(/^ipfs:/i)) {\n                            metadataUrl = getIpfsLink(metadataUrl);\n                        }\n\n                        linkage.push({ type: \"metadata-url\", content: metadataUrl });\n\n                        // Get the token metadata\n                        const metadata = await fetchJson(metadataUrl);\n                        if (!metadata) { return null; }\n                        linkage.push({ type: \"metadata\", content: JSON.stringify(metadata) });\n\n                        // Pull the image URL out\n                        let imageUrl = metadata.image;\n                        if (typeof(imageUrl) !== \"string\") { return null; }\n\n                        if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                            // Allow\n                        } else {\n                            // Transform IPFS link to gateway\n                            const ipfs = imageUrl.match(matcherIpfs);\n                            if (ipfs == null) { return null; }\n\n                            linkage.push({ type: \"url-ipfs\", content: imageUrl });\n                            imageUrl = getIpfsLink(imageUrl);\n                        }\n\n                        linkage.push({ type: \"url\", content: imageUrl });\n\n                        return { linkage, url: imageUrl };\n                    }\n                }\n            }\n        } catch (error) { }\n\n        return null;\n    }\n\n    async getContentHash(): Promise<string> {\n\n        // keccak256(\"contenthash()\")\n        const hexBytes = await this._fetchBytes(\"0xbc1c58d1\");\n\n        // No contenthash\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        // IPFS (CID: 1, Type: DAG-PB)\n        const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipfs) {\n            const length = parseInt(ipfs[3], 16);\n            if (ipfs[4].length === length * 2) {\n                return \"ipfs:/\\/\" + Base58.encode(\"0x\" + ipfs[1]);\n            }\n        }\n\n        // IPNS (CID: 1, Type: libp2p-key)\n        const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipns) {\n            const length = parseInt(ipns[3], 16);\n            if (ipns[4].length === length * 2) {\n                return \"ipns:/\\/\" + Base58.encode(\"0x\" + ipns[1]);\n            }\n        }\n\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n        const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/)\n        if (swarm) {\n            if (swarm[1].length === (32 * 2)) {\n                return \"bzz:/\\/\" + swarm[1]\n            }\n        }\n\n        const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);\n        if (skynet) {\n            if (skynet[1].length === (34 * 2)) {\n                // URL Safe base64; https://datatracker.ietf.org/doc/html/rfc4648#section-5\n                const urlSafe: Record<string, string> = { \"=\": \"\", \"+\": \"-\", \"/\": \"_\" };\n                const hash = base64Encode(\"0x\" + skynet[1]).replace(/[=+\\/]/g, (a) => (urlSafe[a]));\n                return \"sia:/\\/\" + hash;\n            }\n        }\n\n        return logger.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"getContentHash()\",\n            data: hexBytes\n        });\n    }\n\n    async getText(key: string): Promise<string> {\n\n        // The key encoded as parameter to fetchBytes\n        let keyBytes = toUtf8Bytes(key);\n\n        // The nodehash consumes the first slot, so the string pointer targets\n        // offset 64, with the length at offset 64 and data starting at offset 96\n        keyBytes = concat([ bytes32ify(64), bytes32ify(keyBytes.length), keyBytes ]);\n\n        // Pad to word-size (32 bytes)\n        if ((keyBytes.length % 32) !== 0) {\n            keyBytes = concat([ keyBytes, hexZeroPad(\"0x\", 32 - (key.length % 32)) ])\n        }\n\n        const hexBytes = await this._fetchBytes(\"0x59d1d43c\", hexlify(keyBytes));\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        return toUtf8String(hexBytes);\n    }\n}\n\nlet defaultFormatter: Formatter = null;\n\nlet nextPollId = 1;\n\nexport class BaseProvider extends Provider implements EnsProvider {\n    _networkPromise: Promise<Network>;\n    _network: Network;\n\n    _events: Array<Event>;\n\n    formatter: Formatter;\n\n    // To help mitigate the eventually consistent nature of the blockchain\n    // we keep a mapping of events we emit. If we emit an event X, we expect\n    // that a user should be able to query for that event in the callback,\n    // if the node returns null, we stall the response until we get back a\n    // meaningful value, since we may be hitting a re-org, or a node that\n    // has not indexed the event yet.\n    // Events:\n    //   - t:{hash}    - Transaction hash\n    //   - b:{hash}    - BlockHash\n    //   - block       - The most recent emitted block\n    _emitted: { [ eventName: string ]: number | \"pending\" };\n\n    _pollingInterval: number;\n    _poller: NodeJS.Timer;\n    _bootstrapPoll: NodeJS.Timer;\n\n    _lastBlockNumber: number;\n    _maxFilterBlockRange: number;\n\n    _fastBlockNumber: number;\n    _fastBlockNumberPromise: Promise<number>;\n    _fastQueryDate: number;\n\n    _maxInternalBlockNumber: number;\n    _internalBlockNumber: Promise<{ blockNumber: number, reqTime: number, respTime: number }>;\n\n    readonly anyNetwork: boolean;\n\n    disableCcipRead: boolean;\n\n\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */\n\n    constructor(network: Networkish | Promise<Network>) {\n        super();\n\n        // Events being listened to\n        this._events = [];\n\n        this._emitted = { block: -2 };\n\n        this.disableCcipRead = false;\n\n        this.formatter = new.target.getFormatter();\n\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        defineReadOnly(this, \"anyNetwork\", (network === \"any\"));\n        if (this.anyNetwork) { network = this.detectNetwork(); }\n\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error) => { });\n\n            // Trigger initial network setting (async)\n            this._ready().catch((error) => { });\n\n        } else {\n            const knownNetwork = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                defineReadOnly(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n\n            } else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n\n        this._maxInternalBlockNumber = -1024;\n\n        this._lastBlockNumber = -2;\n        this._maxFilterBlockRange = 10;\n\n        this._pollingInterval = 4000;\n\n        this._fastQueryDate = 0;\n    }\n\n    async _ready(): Promise<Network> {\n        if (this._network == null) {\n            let network: Network = null;\n            if (this._networkPromise) {\n                try {\n                    network = await this._networkPromise;\n                } catch (error) { }\n            }\n\n            // Try the Provider's network detection (this MUST throw if it cannot)\n            if (network == null) {\n                network = await this.detectNetwork();\n            }\n\n            // This should never happen; every Provider sub-class should have\n            // suggested a network by here (or have thrown).\n            if (!network) {\n                logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, { });\n            }\n\n            // Possible this call stacked so do not call defineReadOnly again\n            if (this._network == null) {\n                if (this.anyNetwork) {\n                    this._network = network;\n                } else {\n                    defineReadOnly(this, \"_network\", network);\n                }\n                this.emit(\"network\", network, null);\n            }\n        }\n\n        return this._network;\n    }\n\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready(): Promise<Network> {\n        return poll(() => {\n            return this._ready().then((network) => {\n                return network;\n            }, (error) => {\n                // If the network isn't running yet, we will wait\n                if (error.code === Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter(): Formatter {\n        if (defaultFormatter == null) {\n            defaultFormatter = new Formatter();\n        }\n        return defaultFormatter;\n    }\n\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network: Networkish): Network {\n        return getNetwork((network == null) ? \"homestead\": network);\n    }\n\n    async ccipReadFetch(tx: Transaction, calldata: string, urls: Array<string>): Promise<null | string> {\n        if (this.disableCcipRead || urls.length === 0) { return null; }\n\n        const sender = tx.to.toLowerCase();\n        const data = calldata.toLowerCase();\n\n        const errorMessages: Array<string> = [ ];\n\n        for (let i = 0; i < urls.length; i++) {\n            const url = urls[i];\n\n            // URL expansion\n            const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n\n            // If no {data} is present, use POST; otherwise GET\n            const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\n\n            const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n                value.status = response.statusCode;\n                return value;\n            });\n\n            if (result.data) { return result.data; }\n\n            const errorMessage = (result.message || \"unknown error\");\n\n            // 4xx indicates the result is not present; stop\n            if (result.status >= 400 && result.status < 500) {\n                return logger.throwError(`response not found during CCIP fetch: ${ errorMessage }`, Logger.errors.SERVER_ERROR, { url, errorMessage });\n            }\n\n            // 5xx indicates server issue; try the next url\n            errorMessages.push(errorMessage);\n        }\n\n        return logger.throwError(`error encountered during CCIP fetch: ${ errorMessages.map((m) => JSON.stringify(m)).join(\", \") }`, Logger.errors.SERVER_ERROR, {\n            urls, errorMessages\n        });\n    }\n\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    async _getInternalBlockNumber(maxAge: number): Promise<number> {\n        await this._ready();\n\n        // Allowing stale data up to maxAge old\n        if (maxAge > 0) {\n\n            // While there are pending internal block requests...\n            while (this._internalBlockNumber) {\n\n                // ...\"remember\" which fetch we started with\n                const internalBlockNumber = this._internalBlockNumber;\n\n                try {\n                    // Check the result is not too stale\n                    const result = await internalBlockNumber;\n                    if ((getTime() - result.respTime) <= maxAge) {\n                        return result.blockNumber;\n                    }\n\n                    // Too old; fetch a new value\n                    break;\n\n                } catch(error) {\n\n                    // The fetch rejected; if we are the first to get the\n                    // rejection, drop through so we replace it with a new\n                    // fetch; all others blocked will then get that fetch\n                    // which won't match the one they \"remembered\" and loop\n                    if (this._internalBlockNumber === internalBlockNumber) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        const reqTime = getTime();\n\n        const checkInternalBlockNumber = resolveProperties({\n            blockNumber: this.perform(\"getBlockNumber\", { }),\n            networkError: this.getNetwork().then((network) => (null), (error) => (error))\n        }).then(({ blockNumber, networkError }) => {\n            if (networkError) {\n                // Unremember this bad internal block number\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n                throw networkError;\n            }\n\n            const respTime = getTime();\n\n            blockNumber = BigNumber.from(blockNumber).toNumber();\n            if (blockNumber < this._maxInternalBlockNumber) { blockNumber = this._maxInternalBlockNumber; }\n\n            this._maxInternalBlockNumber = blockNumber;\n            this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n            return { blockNumber, reqTime, respTime };\n        });\n\n        this._internalBlockNumber = checkInternalBlockNumber;\n\n        // Swallow unhandled exceptions; if needed they are handled else where\n        checkInternalBlockNumber.catch((error) => {\n            // Don't null the dead (rejected) fetch, if it has already been updated\n            if (this._internalBlockNumber === checkInternalBlockNumber) {\n                this._internalBlockNumber = null;\n            }\n        });\n\n        return (await checkInternalBlockNumber).blockNumber;\n    }\n\n    async poll(): Promise<void> {\n        const pollId = nextPollId++;\n\n        // Track all running promises, so we can trigger a post-poll once they are complete\n        const runners: Array<Promise<void>> = [];\n\n        let blockNumber: number = null;\n        try {\n            blockNumber = await this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n        } catch (error) {\n            this.emit(\"error\", error);\n            return;\n        }\n        this._setFastBlockNumber(blockNumber);\n\n        // Emit a poll event after we have the latest (fast) block number\n        this.emit(\"poll\", pollId, blockNumber);\n\n        // If the block has not changed, meh.\n        if (blockNumber === this._lastBlockNumber) {\n            this.emit(\"didPoll\", pollId);\n            return;\n        }\n\n        // First polling cycle, trigger a \"block\" events\n        if (this._emitted.block === -2) {\n            this._emitted.block = blockNumber - 1;\n        }\n\n        if (Math.abs((<number>(this._emitted.block)) - blockNumber) > 1000) {\n            logger.warn(`network block skew detected; skipping block events (emitted=${ this._emitted.block } blockNumber${ blockNumber })`);\n            this.emit(\"error\", logger.makeError(\"network block skew detected\", Logger.errors.NETWORK_ERROR, {\n                blockNumber: blockNumber,\n                event: \"blockSkew\",\n                previousBlockNumber: this._emitted.block\n            }));\n            this.emit(\"block\", blockNumber);\n\n        } else {\n            // Notify all listener for each block that has passed\n            for (let i = (<number>this._emitted.block) + 1; i <= blockNumber; i++) {\n                this.emit(\"block\", i);\n            }\n        }\n\n        // The emitted block was updated, check for obsolete events\n        if ((<number>this._emitted.block) !== blockNumber) {\n            this._emitted.block = blockNumber;\n\n            Object.keys(this._emitted).forEach((key) => {\n                // The block event does not expire\n                if (key === \"block\") { return; }\n\n                // The block we were at when we emitted this event\n                const eventBlockNumber = this._emitted[key];\n\n                // We cannot garbage collect pending transactions or blocks here\n                // They should be garbage collected by the Provider when setting\n                // \"pending\" events\n                if (eventBlockNumber === \"pending\") { return; }\n\n                // Evict any transaction hashes or block hashes over 12 blocks\n                // old, since they should not return null anyways\n                if (blockNumber - eventBlockNumber > 12) {\n                    delete this._emitted[key];\n                }\n            });\n        }\n\n        // First polling cycle\n        if (this._lastBlockNumber === -2) {\n            this._lastBlockNumber = blockNumber - 1;\n        }\n        // Find all transaction hashes we are waiting on\n        this._events.forEach((event) => {\n            switch (event.type) {\n                case \"tx\": {\n                    const hash = event.hash;\n                    let runner = this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt || receipt.blockNumber == null) { return null; }\n                        this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                        this.emit(hash, receipt);\n                        return null;\n                    }).catch((error: Error) => { this.emit(\"error\", error); });\n\n                    runners.push(runner);\n\n                    break;\n                }\n\n                case \"filter\": {\n                    // We only allow a single getLogs to be in-flight at a time\n                    if (!event._inflight) {\n                        event._inflight = true;\n\n                        // This is the first filter for this event, so we want to\n                        // restrict events to events that happened no earlier than now\n                        if (event._lastBlockNumber === -2) {\n                            event._lastBlockNumber = blockNumber - 1;\n                        }\n\n                        // Filter from the last *known* event; due to load-balancing\n                        // and some nodes returning updated block numbers before\n                        // indexing events, a logs result with 0 entries cannot be\n                        // trusted and we must retry a range which includes it again\n                        const filter = event.filter;\n                        filter.fromBlock = event._lastBlockNumber + 1;\n                        filter.toBlock = blockNumber;\n\n                        // Prevent fitler ranges from growing too wild, since it is quite\n                        // likely there just haven't been any events to move the lastBlockNumber.\n                        const minFromBlock = filter.toBlock - this._maxFilterBlockRange;\n                        if (minFromBlock > filter.fromBlock) { filter.fromBlock = minFromBlock; }\n\n                        if (filter.fromBlock < 0) { filter.fromBlock = 0; }\n\n                        const runner = this.getLogs(filter).then((logs) => {\n                            // Allow the next getLogs\n                            event._inflight = false;\n\n                            if (logs.length === 0) { return; }\n\n                            logs.forEach((log: Log) => {\n                                // Only when we get an event for a given block number\n                                // can we trust the events are indexed\n                                if (log.blockNumber > event._lastBlockNumber) {\n                                    event._lastBlockNumber = log.blockNumber;\n                                }\n\n                                // Make sure we stall requests to fetch blocks and txs\n                                this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                                this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n\n                                this.emit(filter, log);\n                            });\n                        }).catch((error: Error) => {\n                            this.emit(\"error\", error);\n\n                            // Allow another getLogs (the range was not updated)\n                            event._inflight = false;\n                        });\n                        runners.push(runner);\n                    }\n\n                    break;\n                }\n            }\n        });\n\n        this._lastBlockNumber = blockNumber;\n\n        // Once all events for this loop have been processed, emit \"didPoll\"\n        Promise.all(runners).then(() => {\n            this.emit(\"didPoll\", pollId);\n        }).catch((error) => { this.emit(\"error\", error); });\n\n        return;\n    }\n\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber: number): void {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) { this.poll(); }\n    }\n\n    get network(): Network {\n        return this._network;\n    }\n\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    async detectNetwork(): Promise<Network> {\n        return logger.throwError(\"provider does not support network detection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"provider.detectNetwork\"\n        });\n    }\n\n    async getNetwork(): Promise<Network> {\n        const network = await this._ready();\n\n        // Make sure we are still connected to the same network; this is\n        // only an external call for backends which can have the underlying\n        // network change spontaneously\n        const currentNetwork = await this.detectNetwork();\n        if (network.chainId !== currentNetwork.chainId) {\n\n            // We are allowing network changes, things can get complex fast;\n            // make sure you know what you are doing if you use \"any\"\n            if (this.anyNetwork) {\n                this._network = currentNetwork;\n\n                // Reset all internal block number guards and caches\n                this._lastBlockNumber = -2;\n                this._fastBlockNumber = null;\n                this._fastBlockNumberPromise = null;\n                this._fastQueryDate = 0;\n                this._emitted.block = -2;\n                this._maxInternalBlockNumber = -1024;\n                this._internalBlockNumber = null;\n\n                // The \"network\" event MUST happen before this method resolves\n                // so any events have a chance to unregister, so we stall an\n                // additional event loop before returning from /this/ call\n                this.emit(\"network\", currentNetwork, network);\n                await stall(0);\n\n                return this._network;\n            }\n\n            const error = logger.makeError(\"underlying network changed\", Logger.errors.NETWORK_ERROR, {\n                event: \"changed\",\n                network: network,\n                detectedNetwork: currentNetwork\n            });\n\n            this.emit(\"error\", error);\n            throw error;\n        }\n\n        return network;\n    }\n\n    get blockNumber(): number {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {\n            this._setFastBlockNumber(blockNumber);\n        }, (error) => { });\n\n        return (this._fastBlockNumber != null) ? this._fastBlockNumber: -1;\n    }\n\n    get polling(): boolean {\n        return (this._poller != null);\n    }\n\n    set polling(value: boolean) {\n        if (value && !this._poller) {\n            this._poller = setInterval(() => { this.poll(); }, this.pollingInterval);\n\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(() => {\n                    this.poll();\n\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(() => {\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) { this.poll(); }\n\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n\n        } else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n\n    get pollingInterval(): number {\n        return this._pollingInterval;\n    }\n\n    set pollingInterval(value: number) {\n        if (typeof(value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n\n        this._pollingInterval = value;\n\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(() => { this.poll(); }, this._pollingInterval);\n        }\n    }\n\n    _getFastBlockNumber(): Promise<number> {\n        const now = getTime();\n\n        // Stale block number, request a newer value\n        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n\n        return this._fastBlockNumberPromise;\n    }\n\n    _setFastBlockNumber(blockNumber: number): void {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) { return; }\n\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n\n    async waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt> {\n        return this._waitForTransaction(transactionHash, (confirmations == null) ? 1: confirmations, timeout || 0, null);\n    }\n\n    async _waitForTransaction(transactionHash: string, confirmations: number, timeout: number, replaceable: { data: string, from: string, nonce: number, to: string, value: BigNumber, startBlock: number }): Promise<TransactionReceipt> {\n        const receipt = await this.getTransactionReceipt(transactionHash);\n\n        // Receipt is already good\n        if ((receipt ? receipt.confirmations: 0) >= confirmations) { return receipt; }\n\n        // Poll until the receipt is good...\n        return new Promise((resolve, reject) => {\n            const cancelFuncs: Array<() => void> = [];\n\n            let done = false;\n            const alreadyDone = function() {\n                if (done) { return true; }\n                done = true;\n                cancelFuncs.forEach((func) => { func(); });\n                return false;\n            };\n\n            const minedHandler = (receipt: TransactionReceipt) => {\n                if (receipt.confirmations < confirmations) { return; }\n                if (alreadyDone()) { return; }\n                resolve(receipt);\n            }\n            this.on(transactionHash, minedHandler);\n            cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });\n\n            if (replaceable) {\n                let lastBlockNumber = replaceable.startBlock;\n                let scannedBlock: number = null;\n                const replaceHandler = async (blockNumber: number) => {\n                    if (done) { return; }\n\n                    // Wait 1 second; this is only used in the case of a fault, so\n                    // we will trade off a little bit of latency for more consistent\n                    // results and fewer JSON-RPC calls\n                    await stall(1000);\n\n                    this.getTransactionCount(replaceable.from).then(async (nonce) => {\n                        if (done) { return; }\n\n                        if (nonce <= replaceable.nonce) {\n                            lastBlockNumber = blockNumber;\n\n                        } else {\n                            // First check if the transaction was mined\n                            {\n                                const mined = await this.getTransaction(transactionHash);\n                                if (mined && mined.blockNumber != null) { return; }\n                            }\n\n                            // First time scanning. We start a little earlier for some\n                            // wiggle room here to handle the eventually consistent nature\n                            // of blockchain (e.g. the getTransactionCount was for a\n                            // different block)\n                            if (scannedBlock == null) {\n                                scannedBlock = lastBlockNumber - 3;\n                                if (scannedBlock < replaceable.startBlock) {\n                                    scannedBlock = replaceable.startBlock;\n                                }\n                            }\n\n                            while (scannedBlock <= blockNumber) {\n                                if (done) { return; }\n\n                                const block = await this.getBlockWithTransactions(scannedBlock);\n                                for (let ti = 0; ti < block.transactions.length; ti++) {\n                                    const tx = block.transactions[ti];\n\n                                    // Successfully mined!\n                                    if (tx.hash === transactionHash) { return; }\n\n                                    // Matches our transaction from and nonce; its a replacement\n                                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                        if (done) { return; }\n\n                                        // Get the receipt of the replacement\n                                        const receipt = await this.waitForTransaction(tx.hash, confirmations);\n\n                                        // Already resolved or rejected (prolly a timeout)\n                                        if (alreadyDone()) { return; }\n\n                                        // The reason we were replaced\n                                        let reason = \"replaced\";\n                                        if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                            reason = \"repriced\";\n                                        } else  if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                            reason = \"cancelled\"\n                                        }\n\n                                        // Explain why we were replaced\n                                        reject(logger.makeError(\"transaction was replaced\", Logger.errors.TRANSACTION_REPLACED, {\n                                            cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                                            reason,\n                                            replacement: this._wrapTransaction(tx),\n                                            hash: transactionHash,\n                                            receipt\n                                        }));\n\n                                        return;\n                                    }\n                                }\n                                scannedBlock++;\n                            }\n                        }\n\n                        if (done) { return; }\n                        this.once(\"block\", replaceHandler);\n\n                    }, (error) => {\n                        if (done) { return; }\n                        this.once(\"block\", replaceHandler);\n                    });\n                };\n\n                if (done) { return; }\n                this.once(\"block\", replaceHandler);\n\n                cancelFuncs.push(() => {\n                    this.removeListener(\"block\", replaceHandler);\n                });\n            }\n\n            if (typeof(timeout) === \"number\" && timeout > 0) {\n                const timer = setTimeout(() => {\n                    if (alreadyDone()) { return; }\n                    reject(logger.makeError(\"timeout exceeded\", Logger.errors.TIMEOUT, { timeout: timeout }));\n                }, timeout);\n                if (timer.unref) { timer.unref(); }\n\n                cancelFuncs.push(() => { clearTimeout(timer); });\n            }\n        });\n    }\n\n    async getBlockNumber(): Promise<number> {\n        return this._getInternalBlockNumber(0);\n    }\n\n    async getGasPrice(): Promise<BigNumber> {\n        await this.getNetwork();\n\n        const result = await this.perform(\"getGasPrice\", { });\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getGasPrice\",\n                result, error\n            });\n        }\n    }\n\n    async getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getBalance\", params);\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getBalance\",\n                params, result, error\n            });\n        }\n    }\n\n    async getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getTransactionCount\", params);\n        try {\n            return BigNumber.from(result).toNumber();\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getTransactionCount\",\n                params, result, error\n            });\n        }\n    }\n\n    async getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getCode\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getCode\",\n                params, result, error\n            });\n        }\n    }\n\n    async getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag),\n            position: Promise.resolve(position).then((p) => hexValue(p))\n        });\n        const result = await this.perform(\"getStorageAt\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getStorageAt\",\n                params, result, error\n            });\n        }\n    }\n\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx: Transaction, hash?: string, startBlock?: number): TransactionResponse {\n        if (hash != null && hexDataLength(hash) !== 32) { throw new Error(\"invalid response - sendTransaction\"); }\n\n        const result = <TransactionResponse>tx;\n\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n        }\n\n        result.wait = async (confirms?: number, timeout?: number) => {\n            if (confirms == null) { confirms = 1; }\n            if (timeout == null) { timeout = 0; }\n\n            // Get the details to detect replacement\n            let replacement = undefined;\n            if (confirms !== 0 && startBlock != null) {\n                replacement = {\n                    data: tx.data,\n                    from: tx.from,\n                    nonce: tx.nonce,\n                    to: tx.to,\n                    value: tx.value,\n                    startBlock\n                };\n            }\n\n            const receipt = await this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n            if (receipt == null && confirms === 0) { return null; }\n\n            // No longer pending, allow the polling loop to garbage collect this\n            this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n\n            if (receipt.status === 0) {\n                logger.throwError(\"transaction failed\", Logger.errors.CALL_EXCEPTION, {\n                    transactionHash: tx.hash,\n                    transaction: tx,\n                    receipt: receipt\n                });\n            }\n            return receipt;\n        };\n\n        return result;\n    }\n\n    async sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse> {\n        await this.getNetwork();\n        const hexTx = await Promise.resolve(signedTransaction).then(t => hexlify(t));\n        const tx = this.formatter.transaction(signedTransaction);\n        if (tx.confirmations == null) { tx.confirmations = 0; }\n        const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n        try {\n            const hash = await this.perform(\"sendTransaction\", { signedTransaction: hexTx });\n            return this._wrapTransaction(tx, hash, blockNumber);\n        } catch (error) {\n            (<any>error).transaction = tx;\n            (<any>error).transactionHash = tx.hash;\n            throw error;\n        }\n    }\n\n    async _getTransactionRequest(transaction: Deferrable<TransactionRequest>): Promise<Transaction> {\n        const values: any = await transaction;\n\n        const tx: any = { };\n\n        [\"from\", \"to\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v): null))\n        });\n\n        [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? BigNumber.from(v): null));\n        });\n\n        [\"type\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => ((v != null) ? v: null));\n        });\n\n        if (values.accessList) {\n            tx.accessList = this.formatter.accessList(values.accessList);\n        }\n\n        [\"data\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? hexlify(v): null));\n        });\n\n        return this.formatter.transactionRequest(await resolveProperties(tx));\n    }\n\n    async _getFilter(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Filter | FilterByBlockHash> {\n        filter = await filter;\n\n        const result: any = { };\n\n        if (filter.address != null) {\n            result.address = this._getAddress(filter.address);\n        }\n\n        [\"blockHash\", \"topics\"].forEach((key) => {\n            if ((<any>filter)[key] == null) { return; }\n            result[key] = (<any>filter)[key];\n        });\n\n        [\"fromBlock\", \"toBlock\"].forEach((key) => {\n            if ((<any>filter)[key] == null) { return; }\n            result[key] = this._getBlockTag((<any>filter)[key]);\n        });\n\n        return this.formatter.filter(await resolveProperties(result));\n    }\n\n    async _call(transaction: TransactionRequest, blockTag: BlockTag, attempt: number): Promise<string> {\n        if (attempt >= MAX_CCIP_REDIRECTS) {\n            logger.throwError(\"CCIP read exceeded maximum redirections\", Logger.errors.SERVER_ERROR, {\n                redirects: attempt, transaction\n            });\n        }\n\n        const txSender = transaction.to;\n\n        const result = await this.perform(\"call\", { transaction, blockTag });\n\n        // CCIP Read request via OffchainLookup(address,string[],bytes,bytes4,bytes)\n        if (attempt >= 0 && blockTag === \"latest\" && txSender != null && result.substring(0, 10) === \"0x556f1830\" && (hexDataLength(result) % 32 === 4)) {\n            try {\n                const data = hexDataSlice(result, 4);\n\n                // Check the sender of the OffchainLookup matches the transaction\n                const sender = hexDataSlice(data, 0, 32);\n                if (!BigNumber.from(sender).eq(txSender)) {\n                    logger.throwError(\"CCIP Read sender did not match\", Logger.errors.CALL_EXCEPTION, {\n                        name: \"OffchainLookup\",\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        transaction, data: result\n                    });\n                }\n\n                // Read the URLs from the response\n                const urls: Array<string> = [];\n                const urlsOffset = BigNumber.from(hexDataSlice(data, 32, 64)).toNumber();\n                const urlsLength = BigNumber.from(hexDataSlice(data, urlsOffset, urlsOffset + 32)).toNumber();\n                const urlsData = hexDataSlice(data, urlsOffset + 32);\n                for (let u = 0; u < urlsLength; u++) {\n                    const url = _parseString(urlsData, u * 32);\n                    if (url == null) {\n                        logger.throwError(\"CCIP Read contained corrupt URL string\", Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    urls.push(url);\n                }\n\n                // Get the CCIP calldata to forward\n                const calldata = _parseBytes(data, 64);\n\n                // Get the callbackSelector (bytes4)\n                if (!BigNumber.from(hexDataSlice(data, 100, 128)).isZero()) {\n                    logger.throwError(\"CCIP Read callback selector included junk\", Logger.errors.CALL_EXCEPTION, {\n                        name: \"OffchainLookup\",\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        transaction, data: result\n                    });\n                }\n                const callbackSelector = hexDataSlice(data, 96, 100);\n\n                // Get the extra data to send back to the contract as context\n                const extraData = _parseBytes(data, 128);\n\n                const ccipResult = await this.ccipReadFetch(<Transaction>transaction, calldata, urls);\n                if (ccipResult == null) {\n                    logger.throwError(\"CCIP Read disabled or provided no URLs\", Logger.errors.CALL_EXCEPTION, {\n                        name: \"OffchainLookup\",\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        transaction, data: result\n                    });\n                }\n\n                const tx = {\n                    to: txSender,\n                    data: hexConcat([ callbackSelector, encodeBytes([ ccipResult, extraData ]) ])\n                };\n\n                return this._call(tx, blockTag, attempt + 1);\n\n            } catch (error) {\n                if (error.code === Logger.errors.SERVER_ERROR) { throw error; }\n            }\n        }\n\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"call\",\n                params: { transaction, blockTag }, result, error\n            });\n        }\n\n    }\n\n    async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const resolved = await resolveProperties({\n            transaction: this._getTransactionRequest(transaction),\n            blockTag: this._getBlockTag(blockTag),\n            ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)\n        });\n        return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0: -1);\n    }\n\n    async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            transaction: this._getTransactionRequest(transaction)\n        });\n\n        const result = await this.perform(\"estimateGas\", params);\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"estimateGas\",\n                params, result, error\n            });\n        }\n    }\n\n    async _getAddress(addressOrName: string | Promise<string>): Promise<string> {\n        addressOrName = await addressOrName;\n        if (typeof(addressOrName) !== \"string\") {\n            logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n        }\n\n        const address = await this.resolveName(addressOrName);\n        if (address == null) {\n            logger.throwError(\"ENS name not configured\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `resolveName(${ JSON.stringify(addressOrName) })`\n            });\n        }\n        return address;\n    }\n\n    async _getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>, includeTransactions?: boolean): Promise<Block | BlockWithTransactions> {\n        await this.getNetwork();\n\n        blockHashOrBlockTag = await blockHashOrBlockTag;\n\n        // If blockTag is a number (not \"latest\", etc), this is the block number\n        let blockNumber = -128;\n\n        const params: { [key: string]: any } = {\n            includeTransactions: !!includeTransactions\n        };\n\n        if (isHexString(blockHashOrBlockTag, 32)) {\n            params.blockHash = blockHashOrBlockTag;\n        } else {\n            try {\n                params.blockTag = await this._getBlockTag(blockHashOrBlockTag);\n                if (isHexString(params.blockTag)) {\n                    blockNumber = parseInt(params.blockTag.substring(2), 16);\n                }\n            } catch (error) {\n                logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n            }\n        }\n\n        return poll(async () => {\n            const block = await this.perform(\"getBlock\", params);\n\n            // Block was not found\n            if (block == null) {\n\n                // For blockhashes, if we didn't say it existed, that blockhash may\n                // not exist. If we did see it though, perhaps from a log, we know\n                // it exists, and this node is just not caught up yet.\n                if (params.blockHash != null) {\n                    if (this._emitted[\"b:\" + params.blockHash] == null) { return null; }\n                }\n\n                // For block tags, if we are asking for a future block, we return null\n                if (params.blockTag != null) {\n                    if (blockNumber > this._emitted.block) { return null; }\n                }\n\n                // Retry on the next block\n                return undefined;\n            }\n\n            // Add transactions\n            if (includeTransactions) {\n                let blockNumber: number = null;\n                for (let i = 0; i < block.transactions.length; i++) {\n                    const tx = block.transactions[i];\n                    if (tx.blockNumber == null) {\n                        tx.confirmations = 0;\n\n                    } else if (tx.confirmations == null) {\n                        if (blockNumber == null) {\n                            blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                        }\n\n                        // Add the confirmations using the fast block number (pessimistic)\n                        let confirmations = (blockNumber - tx.blockNumber) + 1;\n                        if (confirmations <= 0) { confirmations = 1; }\n                        tx.confirmations = confirmations;\n                    }\n                }\n\n                const blockWithTxs: any = this.formatter.blockWithTransactions(block);\n                blockWithTxs.transactions = blockWithTxs.transactions.map((tx: TransactionResponse) => this._wrapTransaction(tx));\n                return blockWithTxs;\n            }\n\n            return this.formatter.block(block);\n\n        }, { oncePoll: this });\n    }\n\n    getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block> {\n        return <Promise<Block>>(this._getBlock(blockHashOrBlockTag, false));\n    }\n\n    getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions> {\n        return <Promise<BlockWithTransactions>>(this._getBlock(blockHashOrBlockTag, true));\n    }\n\n    async getTransaction(transactionHash: string | Promise<string>): Promise<TransactionResponse> {\n        await this.getNetwork();\n        transactionHash = await transactionHash;\n\n        const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\n        return poll(async () => {\n            const result = await this.perform(\"getTransaction\", params);\n\n            if (result == null) {\n                if (this._emitted[\"t:\" + transactionHash] == null) {\n                    return null;\n                }\n                return undefined;\n            }\n\n            const tx = this.formatter.transactionResponse(result);\n\n            if (tx.blockNumber == null) {\n                tx.confirmations = 0;\n\n            } else if (tx.confirmations == null) {\n                const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n\n                // Add the confirmations using the fast block number (pessimistic)\n                let confirmations = (blockNumber - tx.blockNumber) + 1;\n                if (confirmations <= 0) { confirmations = 1; }\n                tx.confirmations = confirmations;\n            }\n\n            return this._wrapTransaction(tx);\n        }, { oncePoll: this });\n    }\n\n    async getTransactionReceipt(transactionHash: string | Promise<string>): Promise<TransactionReceipt> {\n        await this.getNetwork();\n\n        transactionHash = await transactionHash;\n\n        const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\n        return poll(async () => {\n            const result = await this.perform(\"getTransactionReceipt\", params);\n\n            if (result == null) {\n                if (this._emitted[\"t:\" + transactionHash] == null) {\n                    return null;\n                }\n                return undefined;\n            }\n\n            // \"geth-etc\" returns receipts before they are ready\n            if (result.blockHash == null) { return undefined; }\n\n            const receipt = this.formatter.receipt(result);\n\n            if (receipt.blockNumber == null) {\n                receipt.confirmations = 0;\n\n            } else if (receipt.confirmations == null) {\n                const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n\n                // Add the confirmations using the fast block number (pessimistic)\n                let confirmations = (blockNumber - receipt.blockNumber) + 1;\n                if (confirmations <= 0) { confirmations = 1; }\n                receipt.confirmations = confirmations;\n            }\n\n            return receipt;\n        }, { oncePoll: this });\n    }\n\n    async getLogs(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Array<Log>> {\n        await this.getNetwork();\n        const params = await resolveProperties({ filter: this._getFilter(filter) });\n        const logs: Array<Log> = await this.perform(\"getLogs\", params);\n        logs.forEach((log) => {\n            if (log.removed == null) { log.removed = false; }\n        });\n        return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n    }\n\n    async getEtherPrice(): Promise<number> {\n        await this.getNetwork();\n        return this.perform(\"getEtherPrice\", { });\n    }\n\n    async _getBlockTag(blockTag: BlockTag | Promise<BlockTag>): Promise<BlockTag> {\n        blockTag = await blockTag;\n\n        if (typeof(blockTag) === \"number\" && blockTag < 0) {\n            if (blockTag % 1) {\n                logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n            }\n\n            let blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            blockNumber += blockTag;\n            if (blockNumber < 0) { blockNumber = 0; }\n            return this.formatter.blockTag(blockNumber)\n        }\n\n        return this.formatter.blockTag(blockTag);\n    }\n\n\n    async getResolver(name: string): Promise<null | Resolver> {\n        let currentName = name;\n        while (true) {\n            if (currentName === \"\" || currentName === \".\") { return null; }\n\n            // Optimization since the eth node cannot change and does\n            // not have a wildcard resolver\n            if (name !== \"eth\" && currentName === \"eth\") { return null; }\n\n            // Check the current node for a resolver\n            const addr = await this._getResolver(currentName, \"getResolver\");\n\n            // Found a resolver!\n            if (addr != null) {\n                const resolver = new Resolver(this, addr, name);\n\n                // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                if (currentName !== name && !(await resolver.supportsWildcard())) { return null; }\n\n                return resolver;\n            }\n\n            // Get the parent node\n            currentName = currentName.split(\".\").slice(1).join(\".\");\n        }\n\n    }\n\n    async _getResolver(name: string, operation?: string): Promise<string> {\n        if (operation == null) { operation = \"ENS\"; }\n\n        const network = await this.getNetwork();\n\n        // No ENS...\n        if (!network.ensAddress) {\n            logger.throwError(\n                \"network does not support ENS\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { operation, network: network.name }\n            );\n        }\n\n        try {\n            // keccak256(\"resolver(bytes32)\")\n            const addrData = await this.call({\n                to: network.ensAddress,\n                data: (\"0x0178b8bf\" + namehash(name).substring(2))\n            });\n            return this.formatter.callAddress(addrData);\n        } catch (error) {\n            // ENS registry cannot throw errors on resolver(bytes32)\n        }\n\n        return null;\n    }\n\n    async resolveName(name: string | Promise<string>): Promise<null | string> {\n        name = await name;\n\n        // If it is already an address, nothing to resolve\n        try {\n            return Promise.resolve(this.formatter.address(name));\n        } catch (error) {\n            // If is is a hexstring, the address is bad (See #694)\n            if (isHexString(name)) { throw error; }\n        }\n\n        if (typeof(name) !== \"string\") {\n            logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n        }\n\n        // Get the addr from the resolver\n        const resolver = await this.getResolver(name);\n        if (!resolver) { return null; }\n\n        return await resolver.getAddress();\n    }\n\n    async lookupAddress(address: string | Promise<string>): Promise<null | string> {\n        address = await address;\n        address = this.formatter.address(address);\n\n        const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n\n        const resolverAddr = await this._getResolver(node, \"lookupAddress\");\n        if (resolverAddr == null) { return null; }\n\n        // keccak(\"name(bytes32)\")\n        const name = _parseString(await this.call({\n            to: resolverAddr,\n            data: (\"0x691f3431\" + namehash(node).substring(2))\n        }), 0);\n\n        const addr = await this.resolveName(name);\n        if (addr != address) { return null; }\n\n        return name;\n    }\n\n    async getAvatar(nameOrAddress: string): Promise<null | string> {\n        let resolver: Resolver = null;\n        if (isHexString(nameOrAddress)) {\n            // Address; reverse lookup\n            const address = this.formatter.address(nameOrAddress);\n\n            const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n\n            const resolverAddress = await this._getResolver(node, \"getAvatar\");\n            if (!resolverAddress) { return null; }\n\n            // Try resolving the avatar against the addr.reverse resolver\n            resolver = new Resolver(this, resolverAddress, node);\n            try {\n                const avatar = await resolver.getAvatar();\n                if (avatar) { return avatar.url; }\n            } catch (error) {\n                if (error.code !== Logger.errors.CALL_EXCEPTION) { throw error; }\n            }\n\n            // Try getting the name and performing forward lookup; allowing wildcards\n            try {\n                // keccak(\"name(bytes32)\")\n                const name = _parseString(await this.call({\n                    to: resolverAddress,\n                    data: (\"0x691f3431\" + namehash(node).substring(2))\n                }), 0);\n                resolver = await this.getResolver(name);\n            } catch (error) {\n                if (error.code !== Logger.errors.CALL_EXCEPTION) { throw error; }\n                return null;\n            }\n\n        } else {\n            // ENS name; forward lookup with wildcard\n            resolver = await this.getResolver(nameOrAddress);\n            if (!resolver) { return null; }\n        }\n\n        const avatar = await resolver.getAvatar();\n        if (avatar == null) { return null; }\n\n        return avatar.url;\n    }\n\n    perform(method: string, params: any): Promise<any> {\n        return logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n    }\n\n    _startEvent(event: Event): void {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n\n    _stopEvent(event: Event): void {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n\n    _addEventListener(eventName: EventType, listener: Listener, once: boolean): this {\n        const event = new Event(getEventTag(eventName), listener, once)\n        this._events.push(event);\n        this._startEvent(event);\n\n        return this;\n    }\n\n    on(eventName: EventType, listener: Listener): this {\n        return this._addEventListener(eventName, listener, false);\n    }\n\n    once(eventName: EventType, listener: Listener): this {\n        return this._addEventListener(eventName, listener, true);\n    }\n\n\n    emit(eventName: EventType, ...args: Array<any>): boolean {\n        let result = false;\n\n        let stopped: Array<Event> = [ ];\n\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag) { return true; }\n\n            setTimeout(() => {\n                event.listener.apply(this, args);\n            }, 0);\n\n            result = true;\n\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n\n            return true;\n        });\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return result;\n    }\n\n    listenerCount(eventName?: EventType): number {\n        if (!eventName) { return this._events.length; }\n\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event) => {\n            return (event.tag === eventTag);\n        }).length;\n    }\n\n    listeners(eventName?: EventType): Array<Listener> {\n        if (eventName == null) {\n            return this._events.map((event) => event.listener);\n        }\n\n        let eventTag = getEventTag(eventName);\n        return this._events\n            .filter((event) => (event.tag === eventTag))\n            .map((event) => event.listener);\n    }\n\n    off(eventName: EventType, listener?: Listener): this {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n\n        const stopped: Array<Event> = [ ];\n\n        let found = false;\n\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag || event.listener != listener) { return true; }\n            if (found) { return true; }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return this;\n    }\n\n    removeAllListeners(eventName?: EventType): this {\n        let stopped: Array<Event> = [ ];\n        if (eventName == null) {\n            stopped = this._events;\n\n            this._events = [ ];\n        } else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event) => {\n                if (event.tag !== eventTag) { return true; }\n                stopped.push(event);\n                return false;\n            });\n        }\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return this;\n    }\n}\n","export const HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n\n","\"use strict\";\n\n// See: https://github.com/ethereum/wiki/wiki/JSON-RPC\n\nimport { Provider, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { Signer, TypedDataDomain, TypedDataField, TypedDataSigner } from \"@ethersproject/abstract-signer\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { Bytes, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { checkProperties, deepCopy, Deferrable, defineReadOnly, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { AccessList, accessListify } from \"@ethersproject/transactions\";\nimport { ConnectionInfo, fetchJson, poll } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BaseProvider, Event } from \"./base-provider\";\n\n\nconst errorGas = [ \"call\", \"estimateGas\" ];\n\nfunction spelunk(value: any, requireData: boolean): null | { message: string, data: null | string } {\n    if (value == null) { return null; }\n\n    // These *are* the droids we're looking for.\n    if (typeof(value.message) === \"string\" && value.message.match(\"reverted\")) {\n        const data = isHexString(value.data) ? value.data: null;\n        if (!requireData || data) {\n            return { message: value.message, data };\n        }\n    }\n\n    // Spelunk further...\n    if (typeof(value) === \"object\") {\n        for (const key in value) {\n            const result = spelunk(value[key], requireData);\n            if (result) { return result; }\n        }\n        return null;\n    }\n\n    // Might be a JSON string we can further descend...\n    if (typeof(value) === \"string\") {\n        try {\n            return spelunk(JSON.parse(value), requireData);\n        } catch (error) { }\n    }\n\n    return null;\n}\n\nfunction checkError(method: string, error: any, params: any): any {\n\n    const transaction = params.transaction || params.signedTransaction;\n\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\") {\n        const result = spelunk(error, true);\n        if (result) { return result.data; }\n\n        // Nothing descriptive..\n        logger.throwError(\"missing revert data in call exception; Transaction reverted without a reason string\", Logger.errors.CALL_EXCEPTION, {\n            data: \"0x\", transaction, error\n        });\n    }\n\n    if (method === \"estimateGas\") {\n        // Try to find something, with a preference on SERVER_ERROR body\n        let result = spelunk(error.body, false);\n        if (result == null) { result = spelunk(error, false); }\n\n        // Found \"reverted\", this is a CALL_EXCEPTION\n        if (result) {\n            logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                reason: result.message, method, transaction, error\n            });\n        }\n    }\n\n    // @TODO: Should we spelunk for message too?\n\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof(error.error.message) === \"string\") {\n        message = error.error.message;\n    } else if (typeof(error.body) === \"string\") {\n        message = error.body;\n    } else if (typeof(error.responseText) === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n\n    // \"nonce too low\"\n    if (message.match(/nonce (is )?too low/i)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/i)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            error, method, transaction\n        });\n    }\n\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n\n    throw error;\n}\n\nfunction timer(timeout: number): Promise<any> {\n    return new Promise(function(resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\n\nfunction getResult(payload: { error?: { code?: number, data?: any, message?: string }, result?: any }): any {\n    if (payload.error) {\n        // @TODO: not any\n        const error: any = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n\n    return payload.result;\n}\n\nfunction getLowerCase(value: string): string {\n    if (value) { return value.toLowerCase(); }\n    return value;\n}\n\nconst _constructorGuard = {};\n\nexport class JsonRpcSigner extends Signer implements TypedDataSigner {\n    readonly provider: JsonRpcProvider;\n    _index: number;\n    _address: string;\n\n    constructor(constructorGuard: any, provider: JsonRpcProvider, addressOrIndex?: string | number) {\n        super();\n\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n\n        defineReadOnly(this, \"provider\", provider);\n\n        if (addressOrIndex == null) { addressOrIndex = 0; }\n\n        if (typeof(addressOrIndex) === \"string\") {\n            defineReadOnly(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            defineReadOnly(this, \"_index\", null);\n\n        } else if (typeof(addressOrIndex) === \"number\") {\n            defineReadOnly(this, \"_index\", addressOrIndex);\n            defineReadOnly(this, \"_address\", null);\n\n        } else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n\n    connect(provider: Provider): JsonRpcSigner {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n\n    connectUnchecked(): JsonRpcSigner {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n\n    getAddress(): Promise<string> {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n\n        return this.provider.send(\"eth_accounts\", []).then((accounts) => {\n            if (accounts.length <= this._index) {\n                logger.throwError(\"unknown account #\" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index])\n        });\n    }\n\n    sendUncheckedTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        transaction = shallowCopy(transaction);\n\n        const fromAddress = this.getAddress().then((address) => {\n            if (address) { address = address.toLowerCase(); }\n            return address;\n        });\n\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = shallowCopy(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then(async (to) => {\n                if (to == null) { return null; }\n                const address = await this.provider.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            });\n        }\n\n        return resolveProperties({\n            tx: resolveProperties(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender }) => {\n\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            } else {\n                tx.from = sender;\n            }\n\n            const hexTx = (<any>this.provider.constructor).hexlifyTransaction(tx, { from: true });\n\n            return this.provider.send(\"eth_sendTransaction\", [ hexTx ]).then((hash) => {\n                return hash;\n            }, (error) => {\n                if (typeof(error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected transaction\", Logger.errors.ACTION_REJECTED, {\n                        action: \"sendTransaction\",\n                        transaction: tx\n                    });\n                }\n\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n\n    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        return logger.throwError(\"signing transactions is unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n\n    async sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        // This cannot be mined any earlier than any recent block\n        const blockNumber = await this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n\n        // Send the transaction\n        const hash = await this.sendUncheckedTransaction(transaction);\n\n        try {\n            // Unfortunately, JSON-RPC only provides and opaque transaction hash\n            // for a response, and we need the actual transaction, so we poll\n            // for it; it should show up very quickly\n            return await poll(async () => {\n                const tx = await this.provider.getTransaction(hash);\n                if (tx === null) { return undefined; }\n                return this.provider._wrapTransaction(tx, hash, blockNumber);\n            }, { oncePoll: this.provider });\n        } catch (error) {\n            (<any>error).transactionHash = hash;\n            throw error;\n        }\n    }\n\n    async signMessage(message: Bytes | string): Promise<string> {\n        const data = ((typeof(message) === \"string\") ? toUtf8Bytes(message): message);\n        const address = await this.getAddress();\n        try {\n            return await this.provider.send(\"personal_sign\", [ hexlify(data), address.toLowerCase() ]);\n        } catch (error) {\n            if (typeof(error.message) === \"string\" && error.message.match(/user denied/i)) {\n                logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                    action: \"signMessage\",\n                    from: address,\n                    messageData: message\n                });\n            }\n            throw error;\n        }\n    }\n\n    async _legacySignMessage(message: Bytes | string): Promise<string> {\n        const data = ((typeof(message) === \"string\") ? toUtf8Bytes(message): message);\n        const address = await this.getAddress();\n\n        try {\n            // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n            return await this.provider.send(\"eth_sign\", [ address.toLowerCase(), hexlify(data) ]);\n        } catch (error) {\n            if (typeof(error.message) === \"string\" && error.message.match(/user denied/i)) {\n                logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                    action: \"_legacySignMessage\",\n                    from: address,\n                    messageData: message\n                });\n            }\n            throw error;\n        }\n    }\n\n    async _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        // Populate any ENS names (in-place)\n        const populated = await _TypedDataEncoder.resolveNames(domain, types, value, (name: string) => {\n            return this.provider.resolveName(name);\n        });\n\n        const address = await this.getAddress();\n\n        try {\n            return await this.provider.send(\"eth_signTypedData_v4\", [\n                address.toLowerCase(),\n                JSON.stringify(_TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n            ]);\n        } catch (error) {\n            if (typeof(error.message) === \"string\" && error.message.match(/user denied/i)) {\n                logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                    action: \"_signTypedData\",\n                    from: address,\n                    messageData: { domain: populated.domain, types, value: populated.value }\n                });\n            }\n            throw error;\n        }\n    }\n\n    async unlock(password: string): Promise<boolean> {\n        const provider = this.provider;\n\n        const address = await this.getAddress();\n\n        return provider.send(\"personal_unlockAccount\", [ address.toLowerCase(), password, null ]);\n    }\n}\n\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        return this.sendUncheckedTransaction(transaction).then((hash) => {\n            return <TransactionResponse>{\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations?: number) => { return this.provider.waitForTransaction(hash, confirmations); }\n            };\n        });\n    }\n}\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, gasLimit: true, gasPrice:true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true\n}\n\nexport class JsonRpcProvider extends BaseProvider {\n    readonly connection: ConnectionInfo;\n\n    _pendingFilter: Promise<number>;\n    _nextId: number;\n\n    // During any given event loop, the results for a given call will\n    // all be the same, so we can dedup the calls to save requests and\n    // bandwidth. @TODO: Try out generalizing this against send?\n    _eventLoopCache: Record<string, Promise<any>>;\n    get _cache(): Record<string, Promise<any>> {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = { };\n        }\n        return this._eventLoopCache;\n    }\n\n    constructor(url?: ConnectionInfo | string, network?: Networkish) {\n        let networkOrReady: Networkish | Promise<Network> = network;\n\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then((network) => {\n                        resolve(network);\n                    }, (error) => {\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n\n        super(networkOrReady);\n\n        // Default URL\n        if (!url) { url = getStatic<() => string>(this.constructor, \"defaultUrl\")(); }\n\n        if (typeof(url) === \"string\") {\n            defineReadOnly(this, \"connection\",Object.freeze({\n                url: url\n            }));\n        } else {\n            defineReadOnly(this, \"connection\", Object.freeze(shallowCopy(url)));\n        }\n\n        this._nextId = 42;\n    }\n\n    static defaultUrl(): string {\n        return \"http:/\\/localhost:8545\";\n    }\n\n    detectNetwork(): Promise<Network> {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(() => {\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n\n    async _uncachedDetectNetwork(): Promise<Network> {\n        await timer(0);\n\n        let chainId = null;\n        try {\n            chainId = await this.send(\"eth_chainId\", [ ]);\n        } catch (error) {\n            try {\n                chainId = await this.send(\"net_version\", [ ]);\n            } catch (error) { }\n        }\n\n        if (chainId != null) {\n            const getNetwork = getStatic<(network: Networkish) => Network>(this.constructor, \"getNetwork\");\n            try {\n                return getNetwork(BigNumber.from(chainId).toNumber());\n            } catch (error) {\n                return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                    chainId: chainId,\n                    event: \"invalidNetwork\",\n                    serverError: error\n                });\n            }\n        }\n\n        return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n            event: \"noNetwork\"\n        });\n    }\n\n    getSigner(addressOrIndex?: string | number): JsonRpcSigner {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n\n    getUncheckedSigner(addressOrIndex?: string | number): UncheckedJsonRpcSigner {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n\n    listAccounts(): Promise<Array<string>> {\n        return this.send(\"eth_accounts\", []).then((accounts: Array<string>) => {\n            return accounts.map((a) => this.formatter.address(a));\n        });\n    }\n\n    send(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: deepCopy(request),\n            provider: this\n        });\n\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = ([ \"eth_chainId\", \"eth_blockNumber\" ].indexOf(method) >= 0);\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n\n        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n\n            return result;\n\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n\n            throw error;\n        });\n\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(() => {\n                this._cache[method] = null;\n            }, 0);\n        }\n\n        return result;\n    }\n\n    prepareRequest(method: string, params: any): [ string, Array<any> ] {\n        switch (method) {\n            case \"getBlockNumber\":\n                return [ \"eth_blockNumber\", [] ];\n\n            case \"getGasPrice\":\n                return [ \"eth_gasPrice\", [] ];\n\n            case \"getBalance\":\n                return [ \"eth_getBalance\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getTransactionCount\":\n                return [ \"eth_getTransactionCount\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getCode\":\n                return [ \"eth_getCode\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getStorageAt\":\n                return [ \"eth_getStorageAt\", [ getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag ] ];\n\n            case \"sendTransaction\":\n                return [ \"eth_sendRawTransaction\", [ params.signedTransaction ] ]\n\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [ \"eth_getBlockByNumber\", [ params.blockTag, !!params.includeTransactions ] ];\n                } else if (params.blockHash) {\n                    return [ \"eth_getBlockByHash\", [ params.blockHash, !!params.includeTransactions ] ];\n                }\n                return null;\n\n            case \"getTransaction\":\n                return [ \"eth_getTransactionByHash\", [ params.transactionHash ] ];\n\n            case \"getTransactionReceipt\":\n                return [ \"eth_getTransactionReceipt\", [ params.transactionHash ] ];\n\n            case \"call\": {\n                const hexlifyTransaction = getStatic<(t: TransactionRequest, a?: { [key: string]: boolean }) => { [key: string]: string }>(this.constructor, \"hexlifyTransaction\");\n                return [ \"eth_call\", [ hexlifyTransaction(params.transaction, { from: true }), params.blockTag ] ];\n            }\n\n            case \"estimateGas\": {\n                const hexlifyTransaction = getStatic<(t: TransactionRequest, a?: { [key: string]: boolean }) => { [key: string]: string }>(this.constructor, \"hexlifyTransaction\");\n                return [ \"eth_estimateGas\", [ hexlifyTransaction(params.transaction, { from: true }) ] ];\n            }\n\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [ \"eth_getLogs\", [ params.filter ] ];\n\n            default:\n                break;\n        }\n\n        return null;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n        // Legacy networks do not like the type field being passed along (which\n        // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n        if (method === \"call\" || method === \"estimateGas\") {\n            const tx = params.transaction;\n            if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {\n                // If there are no EIP-1559 properties, it might be non-EIP-1559\n                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                    const feeData = await this.getFeeData();\n                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                        // Network doesn't know about EIP-1559 (and hence type)\n                        params = shallowCopy(params);\n                        params.transaction = shallowCopy(tx);\n                        delete params.transaction.type;\n                    }\n                }\n            }\n        }\n\n        const args = this.prepareRequest(method,  params);\n\n        if (args == null) {\n            logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n        }\n        try {\n            return await this.send(args[0], args[1])\n        } catch (error) {\n            return checkError(method, error, params);\n        }\n    }\n\n    _startEvent(event: Event): void {\n        if (event.tag === \"pending\") { this._startPending(); }\n        super._startEvent(event);\n    }\n\n    _startPending(): void {\n        if (this._pendingFilter != null) { return; }\n        const self = this;\n\n        const pendingFilter: Promise<number> = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n\n        pendingFilter.then(function(filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [ filterId ]).then(function(hashes: Array<string>) {\n                    if (self._pendingFilter != pendingFilter) { return null; }\n\n                    let seq = Promise.resolve();\n                    hashes.forEach(function(hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function() {\n                            return self.getTransaction(hash).then(function(tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n\n                    return seq.then(function() {\n                        return timer(1000);\n                    });\n                }).then(function() {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [ filterId ]);\n                        return;\n                    }\n                    setTimeout(function() { poll(); }, 0);\n\n                    return null;\n                }).catch((error: Error) => { });\n            }\n            poll();\n\n            return filterId;\n        }).catch((error: Error) => { });\n    }\n\n    _stopEvent(event: Event): void {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction: TransactionRequest, allowExtra?: { [key: string]: boolean }): { [key: string]: string | AccessList } {\n        // Check only allowed properties are given\n        const allowed = shallowCopy(allowedTransactionKeys);\n        if (allowExtra) {\n            for (const key in allowExtra) {\n                if (allowExtra[key]) { allowed[key] = true; }\n            }\n        }\n\n        checkProperties(transaction, allowed);\n\n        const result: { [key: string]: string | AccessList } = {};\n\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function(key) {\n            if ((<any>transaction)[key] == null) { return; }\n            const value = hexValue(BigNumber.from((<any>transaction)[key]));\n            if (key === \"gasLimit\") { key = \"gas\"; }\n            result[key] = value;\n        });\n\n        [\"from\", \"to\", \"data\"].forEach(function(key) {\n            if ((<any>transaction)[key] == null) { return; }\n            result[key] = hexlify((<any>transaction)[key]);\n        });\n\n        if ((<any>transaction).accessList) {\n            result[\"accessList\"] = accessListify((<any>transaction).accessList);\n        }\n\n        return result;\n    }\n}\n","\"use strict\";\n\nimport { Networkish } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n\n// Exported Types\nexport type ExternalProvider = {\n    isMetaMask?: boolean;\n    isStatus?: boolean;\n    host?: string;\n    path?: string;\n    sendAsync?: (request: { method: string, params?: Array<any> }, callback: (error: any, response: any) => void) => void\n    send?: (request: { method: string, params?: Array<any> }, callback: (error: any, response: any) => void) => void\n    request?: (request: { method: string, params?: Array<any> }) => Promise<any>\n}\n\nlet _nextId = 1;\n\nexport type JsonRpcFetchFunc = (method: string, params?: Array<any>) => Promise<any>;\n\ntype Web3LegacySend = (request: any, callback: (error: Error, response: any) => void) => void;\n\nfunction buildWeb3LegacyFetcher(provider: ExternalProvider, sendFunc: Web3LegacySend) : JsonRpcFetchFunc {\n    const fetcher = \"Web3LegacyFetcher\";\n\n    return function(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (_nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        return new Promise((resolve, reject) => {\n            this.emit(\"debug\", {\n                action: \"request\",\n                fetcher,\n                request: deepCopy(request),\n                provider: this\n            });\n\n            sendFunc(request, (error, response) => {\n\n                if (error) {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        fetcher,\n                        error,\n                        request,\n                        provider: this\n                    });\n\n                    return reject(error);\n                }\n\n                this.emit(\"debug\", {\n                    action: \"response\",\n                    fetcher,\n                    request,\n                    response,\n                    provider: this\n                });\n\n                if (response.error) {\n                    const error = new Error(response.error.message);\n                    (<any>error).code = response.error.code;\n                    (<any>error).data = response.error.data;\n                    return reject(error);\n                }\n\n                resolve(response.result);\n            });\n        });\n    }\n}\n\nfunction buildEip1193Fetcher(provider: ExternalProvider): JsonRpcFetchFunc {\n    return function(method: string, params: Array<any>): Promise<any> {\n        if (params == null) { params = [ ]; }\n\n        const request = { method, params };\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            fetcher: \"Eip1193Fetcher\",\n            request: deepCopy(request),\n            provider: this\n        });\n\n        return provider.request(request).then((response) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                response,\n                provider: this\n            });\n\n            return response;\n\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                error,\n                provider: this\n            });\n\n            throw error;\n        });\n    }\n}\n\nexport class Web3Provider extends JsonRpcProvider {\n    readonly provider: ExternalProvider;\n    readonly jsonRpcFetchFunc: JsonRpcFetchFunc;\n\n    constructor(provider: ExternalProvider | JsonRpcFetchFunc, network?: Networkish) {\n        if (provider == null) {\n            logger.throwArgumentError(\"missing provider\", \"provider\", provider);\n        }\n\n        let path: string = null;\n        let jsonRpcFetchFunc: JsonRpcFetchFunc = null;\n        let subprovider: ExternalProvider = null;\n\n        if (typeof(provider) === \"function\") {\n            path = \"unknown:\";\n            jsonRpcFetchFunc = provider;\n\n        } else {\n            path = provider.host || provider.path || \"\";\n            if (!path && provider.isMetaMask) {\n                path = \"metamask\";\n            }\n\n            subprovider = provider;\n\n            if (provider.request) {\n                if (path === \"\") { path = \"eip-1193:\"; }\n                jsonRpcFetchFunc = buildEip1193Fetcher(provider);\n            } else if (provider.sendAsync) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));\n            } else if (provider.send) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));\n            } else {\n                logger.throwArgumentError(\"unsupported provider\", \"provider\", provider);\n            }\n\n            if (!path) { path = \"unknown:\"; }\n        }\n\n        super(path, network);\n\n        defineReadOnly(this, \"jsonRpcFetchFunc\", jsonRpcFetchFunc);\n        defineReadOnly(this, \"provider\", subprovider);\n    }\n\n    send(method: string, params: Array<any>): Promise<any> {\n        return this.jsonRpcFetchFunc(method, params);\n    }\n}\n","\"use strict\";\n\nimport { arrayify, BytesLike, hexZeroPad, isBytes } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BigNumber, BigNumberish, isBigNumberish } from \"./bignumber\";\n\nconst _constructorGuard = { };\n\nconst Zero = BigNumber.from(0);\nconst NegativeOne = BigNumber.from(-1);\n\nfunction throwFault(message: string, fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value !== undefined) { params.value = value; }\n    return logger.throwError(message, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// Constant to pull zeros from for multipliers\nlet zeros = \"0\";\nwhile (zeros.length < 256) { zeros += zeros; }\n\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getMultiplier(decimals: BigNumberish): string {\n\n    if (typeof(decimals) !== \"number\") {\n        try {\n            decimals = BigNumber.from(decimals).toNumber();\n        } catch (e) { }\n    }\n\n    if (typeof(decimals) === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n        return (\"1\" + zeros.substring(0, decimals));\n    }\n\n    return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\n\nexport function formatFixed(value: BigNumberish, decimals?: string | BigNumberish): string {\n    if (decimals == null) { decimals = 0; }\n    const multiplier = getMultiplier(decimals);\n\n    // Make sure wei is a big number (convert as necessary)\n    value = BigNumber.from(value);\n\n    const negative = value.lt(Zero);\n    if (negative) { value = value.mul(NegativeOne); }\n\n    let fraction = value.mod(multiplier).toString();\n    while (fraction.length < multiplier.length - 1) { fraction = \"0\" + fraction; }\n\n    // Strip training 0\n    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n\n    const whole = value.div(multiplier).toString();\n    if (multiplier.length === 1) {\n        value = whole;\n    } else {\n        value = whole + \".\" + fraction;\n    }\n\n    if (negative) { value = \"-\" + value; }\n\n    return value;\n}\n\nexport function parseFixed(value: string, decimals?: BigNumberish): BigNumber {\n\n    if (decimals == null) { decimals = 0; }\n    const multiplier = getMultiplier(decimals);\n\n    if (typeof(value) !== \"string\" || !value.match(/^-?[0-9.]+$/)) {\n        logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n    }\n\n    // Is it negative?\n    const negative = (value.substring(0, 1) === \"-\");\n    if (negative) { value = value.substring(1); }\n\n    if (value === \".\") {\n        logger.throwArgumentError(\"missing value\", \"value\", value);\n    }\n\n    // Split it into a whole and fractional part\n    const comps = value.split(\".\");\n    if (comps.length > 2) {\n        logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n    }\n\n    let whole = comps[0], fraction = comps[1];\n    if (!whole) { whole = \"0\"; }\n    if (!fraction) { fraction = \"0\"; }\n\n    // Trim trailing zeros\n    while (fraction[fraction.length - 1] === \"0\") {\n        fraction = fraction.substring(0, fraction.length - 1);\n    }\n\n    // Check the fraction doesn't exceed our decimals size\n    if (fraction.length > multiplier.length - 1) {\n        throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n    }\n\n    // If decimals is 0, we have an empty string for fraction\n    if (fraction === \"\") { fraction = \"0\"; }\n\n    // Fully pad the string with zeros to get to wei\n    while (fraction.length < multiplier.length - 1) { fraction += \"0\"; }\n\n    const wholeValue = BigNumber.from(whole);\n    const fractionValue = BigNumber.from(fraction);\n\n    let wei = (wholeValue.mul(multiplier)).add(fractionValue);\n\n    if (negative) { wei = wei.mul(NegativeOne); }\n\n    return wei;\n}\n\n\nexport class FixedFormat {\n    readonly signed: boolean;\n    readonly width: number;\n    readonly decimals: number;\n    readonly name: string;\n    readonly _multiplier: string;\n\n    constructor(constructorGuard: any, signed: boolean, width: number, decimals: number) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n\n        this.signed = signed;\n        this.width = width;\n        this.decimals = decimals;\n\n        this.name = (signed ? \"\": \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n\n        this._multiplier = getMultiplier(decimals);\n\n        Object.freeze(this);\n    }\n\n    static from(value: any): FixedFormat {\n        if (value instanceof FixedFormat) { return value; }\n\n        if (typeof(value) === \"number\") {\n            value = `fixed128x${value}`\n        }\n\n        let signed = true;\n        let width = 128;\n        let decimals = 18;\n\n        if (typeof(value) === \"string\") {\n            if (value === \"fixed\") {\n                // defaults...\n            } else if (value === \"ufixed\") {\n                signed = false;\n            } else {\n                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n                if (!match) { logger.throwArgumentError(\"invalid fixed format\", \"format\", value); }\n                signed = (match[1] !== \"u\");\n                width = parseInt(match[2]);\n                decimals = parseInt(match[3]);\n            }\n        } else if (value) {\n            const check = (key: string, type: string, defaultValue: any): any => {\n                if (value[key] == null) { return defaultValue; }\n                if (typeof(value[key]) !== type) {\n                    logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type +\")\", \"format.\" + key, value[key]);\n                }\n                return value[key];\n            }\n            signed = check(\"signed\", \"boolean\", signed);\n            width = check(\"width\", \"number\", width);\n            decimals = check(\"decimals\", \"number\", decimals);\n        }\n\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n        }\n\n        if (decimals > 80) {\n            logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n        }\n\n        return new FixedFormat(_constructorGuard, signed, width, decimals);\n    }\n}\n\nexport class FixedNumber {\n    readonly format: FixedFormat;\n    readonly _hex: string;\n    readonly _value: string;\n\n    readonly _isFixedNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string, value: string, format?: FixedFormat) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n\n        this.format = format;\n        this._hex = hex;\n        this._value = value;\n\n        this._isFixedNumber = true;\n\n        Object.freeze(this);\n    }\n\n    _checkFormat(other: FixedNumber): void {\n        if (this.format.name !== other.format.name) {\n            logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n        }\n    }\n\n    addUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n    }\n\n    subUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n    }\n\n    mulUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n    }\n\n    divUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n    }\n\n    floor(): FixedNumber {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) { comps.push(\"0\"); }\n\n        let result = FixedNumber.from(comps[0], this.format);\n\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (this.isNegative() && hasFraction) {\n            result = result.subUnsafe(ONE.toFormat(result.format));\n        }\n\n        return result;\n    }\n\n    ceiling(): FixedNumber {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) { comps.push(\"0\"); }\n\n        let result = FixedNumber.from(comps[0], this.format);\n\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (!this.isNegative() && hasFraction) {\n            result = result.addUnsafe(ONE.toFormat(result.format));\n        }\n\n        return result;\n    }\n\n    // @TODO: Support other rounding algorithms\n    round(decimals?: number): FixedNumber {\n        if (decimals == null) { decimals = 0; }\n\n        // If we are already in range, we're done\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) { comps.push(\"0\"); }\n\n        if (decimals < 0 || decimals > 80 || (decimals % 1)) {\n            logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n        }\n\n        if (comps[1].length <= decimals) { return this; }\n\n        const factor = FixedNumber.from(\"1\" + zeros.substring(0, decimals), this.format);\n        const bump = BUMP.toFormat(this.format);\n\n        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);\n    }\n\n    isZero(): boolean {\n        return (this._value === \"0.0\" || this._value === \"0\");\n    }\n\n    isNegative(): boolean {\n        return (this._value[0] === \"-\");\n    }\n\n    toString(): string { return this._value; }\n\n    toHexString(width?: number): string {\n        if (width == null) { return this._hex; }\n        if (width % 8) { logger.throwArgumentError(\"invalid byte width\", \"width\", width); }\n        const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n        return hexZeroPad(hex, width / 8);\n    }\n\n    toUnsafeFloat(): number { return parseFloat(this.toString()); }\n\n    toFormat(format: FixedFormat | string): FixedNumber {\n        return FixedNumber.fromString(this._value, format);\n    }\n\n\n    static fromValue(value: BigNumber, decimals?: BigNumberish, format?: FixedFormat | string | number): FixedNumber {\n        // If decimals looks more like a format, and there is no format, shift the parameters\n        if (format == null && decimals != null && !isBigNumberish(decimals)) {\n            format = decimals;\n            decimals = null;\n        }\n\n        if (decimals == null) { decimals = 0; }\n        if (format == null) { format = \"fixed\"; }\n\n        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n    }\n\n\n    static fromString(value: string, format?: FixedFormat | string | number): FixedNumber {\n        if (format == null) { format = \"fixed\"; }\n\n        const fixedFormat = FixedFormat.from(format);\n\n        const numeric = parseFixed(value, fixedFormat.decimals);\n\n        if (!fixedFormat.signed && numeric.lt(Zero)) {\n            throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n        }\n\n        let hex: string = null;\n        if (fixedFormat.signed) {\n            hex = numeric.toTwos(fixedFormat.width).toHexString();\n        } else {\n            hex = numeric.toHexString();\n            hex = hexZeroPad(hex, fixedFormat.width / 8);\n        }\n\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n\n    static fromBytes(value: BytesLike, format?: FixedFormat | string | number): FixedNumber {\n        if (format == null) { format = \"fixed\"; }\n\n        const fixedFormat = FixedFormat.from(format);\n\n        if (arrayify(value).length > fixedFormat.width / 8) {\n            throw new Error(\"overflow\");\n        }\n\n        let numeric = BigNumber.from(value);\n        if (fixedFormat.signed) { numeric = numeric.fromTwos(fixedFormat.width); }\n\n        const hex = numeric.toTwos((fixedFormat.signed ? 0: 1) + fixedFormat.width).toHexString();\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n\n    static from(value: any, format?: FixedFormat | string | number) {\n        if (typeof(value) === \"string\") {\n            return FixedNumber.fromString(value, format);\n        }\n\n        if (isBytes(value)) {\n            return FixedNumber.fromBytes(value, format);\n        }\n\n        try {\n            return FixedNumber.fromValue(value, 0, format);\n        } catch (error) {\n            // Allow NUMERIC_FAULT to bubble up\n            if (error.code !== Logger.errors.INVALID_ARGUMENT) {\n                throw error;\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n    }\n\n    static isFixedNumber(value: any): value is FixedNumber {\n        return !!(value && value._isFixedNumber);\n    }\n}\n\nconst ONE = FixedNumber.from(1);\nconst BUMP = FixedNumber.from(\"0.5\");\n","\"use strict\";\n\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { formatFixed, parseFixed } from \"@ethersproject/bignumber\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst names = [\n    \"wei\",\n    \"kwei\",\n    \"mwei\",\n    \"gwei\",\n    \"szabo\",\n    \"finney\",\n    \"ether\",\n];\n\n\n// Some environments have issues with RegEx that contain back-tracking, so we cannot\n// use them.\nexport function commify(value: string | number): string {\n    const comps = String(value).split(\".\");\n\n    if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || (comps[1] && !comps[1].match(/^[0-9]*$/)) || value === \".\" || value === \"-.\") {\n        logger.throwArgumentError(\"invalid value\", \"value\", value);\n    }\n\n    // Make sure we have at least one whole digit (0 if none)\n    let whole = comps[0];\n\n    let negative = \"\";\n    if (whole.substring(0, 1) === \"-\") {\n        negative = \"-\";\n        whole = whole.substring(1);\n    }\n\n    // Make sure we have at least 1 whole digit with no leading zeros\n    while (whole.substring(0, 1) === \"0\") { whole = whole.substring(1); }\n    if (whole === \"\") { whole = \"0\"; }\n\n    let suffix = \"\";\n    if (comps.length === 2) { suffix = \".\" + (comps[1] || \"0\"); }\n    while (suffix.length > 2 && suffix[suffix.length - 1] === \"0\") {\n        suffix = suffix.substring(0, suffix.length - 1);\n    }\n\n    const formatted = [];\n    while (whole.length) {\n        if (whole.length <= 3) {\n            formatted.unshift(whole);\n            break;\n        } else {\n            const index = whole.length - 3;\n            formatted.unshift(whole.substring(index));\n            whole = whole.substring(0, index);\n        }\n    }\n\n    return negative + formatted.join(\",\") + suffix;\n}\n\nexport function formatUnits(value: BigNumberish, unitName?: string | BigNumberish): string {\n    if (typeof(unitName) === \"string\") {\n        const index = names.indexOf(unitName);\n        if (index !== -1) { unitName = 3 * index; }\n    }\n    return formatFixed(value, (unitName != null) ? unitName: 18);\n}\n\nexport function parseUnits(value: string, unitName?: BigNumberish): BigNumber {\n    if (typeof(value) !== \"string\") {\n        logger.throwArgumentError(\"value must be a string\", \"value\", value);\n    }\n    if (typeof(unitName) === \"string\") {\n        const index = names.indexOf(unitName);\n        if (index !== -1) { unitName = 3 * index; }\n    }\n    return parseFixed(value, (unitName != null) ? unitName: 18);\n}\n\nexport function formatEther(wei: BigNumberish): string {\n    return formatUnits(wei, 18);\n}\n\nexport function parseEther(ether: string): BigNumber {\n    return parseUnits(ether, 18);\n}\n\n","export const version = \"units/5.7.0\";\n","'use strict'\nvar ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'\n\n// pre-compute lookup table\nvar ALPHABET_MAP = {}\nfor (var z = 0; z < ALPHABET.length; z++) {\n  var x = ALPHABET.charAt(z)\n\n  if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous')\n  ALPHABET_MAP[x] = z\n}\n\nfunction polymodStep (pre) {\n  var b = pre >> 25\n  return ((pre & 0x1FFFFFF) << 5) ^\n    (-((b >> 0) & 1) & 0x3b6a57b2) ^\n    (-((b >> 1) & 1) & 0x26508e6d) ^\n    (-((b >> 2) & 1) & 0x1ea119fa) ^\n    (-((b >> 3) & 1) & 0x3d4233dd) ^\n    (-((b >> 4) & 1) & 0x2a1462b3)\n}\n\nfunction prefixChk (prefix) {\n  var chk = 1\n  for (var i = 0; i < prefix.length; ++i) {\n    var c = prefix.charCodeAt(i)\n    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')'\n\n    chk = polymodStep(chk) ^ (c >> 5)\n  }\n  chk = polymodStep(chk)\n\n  for (i = 0; i < prefix.length; ++i) {\n    var v = prefix.charCodeAt(i)\n    chk = polymodStep(chk) ^ (v & 0x1f)\n  }\n  return chk\n}\n\nfunction encode (prefix, words, LIMIT) {\n  LIMIT = LIMIT || 90\n  if ((prefix.length + 7 + words.length) > LIMIT) throw new TypeError('Exceeds length limit')\n\n  prefix = prefix.toLowerCase()\n\n  // determine chk mod\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') throw new Error(chk)\n\n  var result = prefix + '1'\n  for (var i = 0; i < words.length; ++i) {\n    var x = words[i]\n    if ((x >> 5) !== 0) throw new Error('Non 5-bit word')\n\n    chk = polymodStep(chk) ^ x\n    result += ALPHABET.charAt(x)\n  }\n\n  for (i = 0; i < 6; ++i) {\n    chk = polymodStep(chk)\n  }\n  chk ^= 1\n\n  for (i = 0; i < 6; ++i) {\n    var v = (chk >> ((5 - i) * 5)) & 0x1f\n    result += ALPHABET.charAt(v)\n  }\n\n  return result\n}\n\nfunction __decode (str, LIMIT) {\n  LIMIT = LIMIT || 90\n  if (str.length < 8) return str + ' too short'\n  if (str.length > LIMIT) return 'Exceeds length limit'\n\n  // don't allow mixed case\n  var lowered = str.toLowerCase()\n  var uppered = str.toUpperCase()\n  if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str\n  str = lowered\n\n  var split = str.lastIndexOf('1')\n  if (split === -1) return 'No separator character for ' + str\n  if (split === 0) return 'Missing prefix for ' + str\n\n  var prefix = str.slice(0, split)\n  var wordChars = str.slice(split + 1)\n  if (wordChars.length < 6) return 'Data too short'\n\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') return chk\n\n  var words = []\n  for (var i = 0; i < wordChars.length; ++i) {\n    var c = wordChars.charAt(i)\n    var v = ALPHABET_MAP[c]\n    if (v === undefined) return 'Unknown character ' + c\n    chk = polymodStep(chk) ^ v\n\n    // not in the checksum?\n    if (i + 6 >= wordChars.length) continue\n    words.push(v)\n  }\n\n  if (chk !== 1) return 'Invalid checksum for ' + str\n  return { prefix: prefix, words: words }\n}\n\nfunction decodeUnsafe () {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n}\n\nfunction decode (str) {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n\n  throw new Error(res)\n}\n\nfunction convert (data, inBits, outBits, pad) {\n  var value = 0\n  var bits = 0\n  var maxV = (1 << outBits) - 1\n\n  var result = []\n  for (var i = 0; i < data.length; ++i) {\n    value = (value << inBits) | data[i]\n    bits += inBits\n\n    while (bits >= outBits) {\n      bits -= outBits\n      result.push((value >> bits) & maxV)\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      result.push((value << (outBits - bits)) & maxV)\n    }\n  } else {\n    if (bits >= inBits) return 'Excess padding'\n    if ((value << (outBits - bits)) & maxV) return 'Non-zero padding'\n  }\n\n  return result\n}\n\nfunction toWordsUnsafe (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n}\n\nfunction toWords (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nfunction fromWordsUnsafe (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n}\n\nfunction fromWords (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nmodule.exports = {\n  decodeUnsafe: decodeUnsafe,\n  decode: decode,\n  encode: encode,\n  toWordsUnsafe: toWordsUnsafe,\n  toWords: toWords,\n  fromWordsUnsafe: fromWordsUnsafe,\n  fromWords: fromWords\n}\n"],"names":["version","logger","Logger","padding","Uint8Array","fill","NegativeOne","BigNumber","Zero","One","MaxUint256","hexTrue","hexZeroPad","toHexString","hexFalse","domainFieldTypes","name","chainId","verifyingContract","salt","domainFieldNames","checkString","key","value","throwArgumentError","concat","JSON","stringify","domainChecks","toString","error","getAddress","toLowerCase","bytes","arrayify","length","Error","hexlify","getBaseEncoder","type","match","signed","width","parseInt","String","boundsUpper","mask","boundsLower","add","mul","v","lt","gt","toTwos","padOffset","hexConcat","slice","hexPadRight","keccak256","id","encodeType","fields","map","_ref","join","TypedDataEncoder","types","_classCallCheck","defineReadOnly","this","Object","freeze","deepCopy","links","parents","subtypes","keys","forEach","_loop","uniqueNames","field","baseType","push","primaryTypes","filter","n","t","checkCircular","found","child","subtype","primaryType","st","sort","_types","_createClass","encoder","_encoderCache","_getEncoder","_this","subEncoder","getEncoder","result","encodedType","values","_ref2","unshift","encodeData","hashStruct","callback","_this2","_visit","reduce","accum","_ref3","from","domain","domainFields","a","b","indexOf","EIP712Domain","hashDomain","hash","encode","resolveName","shallowCopy","ensCache","isHexString","visit","_context","t0","_regeneratorRuntime","t1","done","next","sent","abrupt","stop","_callee","domainValues","domainTypes","typesWithDomain","message","decode","textData","atob","data","i","charCodeAt","fromCharCode","btoa","getUrl","href","options","request","method","headers","body","undefined","skipFetchSetup","mode","cache","credentials","redirect","referrer","fetchOptions","opts","fetch","response","arrayBuffer","get","statusCode","status","statusMessage","statusText","staller","duration","Promise","resolve","setTimeout","bodyify","isBytesLike","split","trim","toUtf8String","fetchJson","connection","json","processFunc","toUtf8Bytes","updated","url","k","attemptLimit","throttleLimit","assertArgument","throttleCallback","throttleSlotInterval","errorPassThrough","allow304","timeout","allowGzip","user","password","substring","allowInsecureAuthentication","throwError","argument","authorization","base64Encode","reData","RegExp","dataMatch","base64Decode","replace","all","code","requestBody","requestMethod","flatHeaders","header","runningTimeout","timer","promise","reject","makeError","cancel","clearTimeout","runningFetch","attempt","prev","location","tryAgain","stall","retryAfter","Math","random","pow","serverError","throttleRetry","race","_fetchData","parse","poll","func","floor","ceiling","interval","retryLimit","check","then","oncePoll","once","onceBlock","BaseX","alphabet","charAt","_alphabetMap","source","digits","carry","j","base","string","_leader","q","TypeError","byte","reverse","Base58","flat","array","depth","flatDeep","arr","call","val","Array","isArray","read_compressed_payload","pos","read_payload","u16","symbol_count","total","acc","skip","pos_payload","read_width","read_buffer","read_bit","FULL","HALF","QRTR","MASK","register","symbols","low","range","start","end","mid","offset","x","decode_arithmetic","read_ascending","read_deltas","read_member_array","lookup","vX","vN","read_counts","read_transposed","w","m","read_linear_table","dx","dy","read_zero_terminated_array","ys","_","j_dy","y","read_replacement_table","r","VALID","Set","IGNORED","MAPPED","ret","fromEntries","read_mapped_map","EMOJI_ROOT","sorted","read","branches","set","node","size","temp","valid","fe0f","save","read_emoji_trie","HYPHEN","UNDERSCORE","explode_cp","toUtf8CodePoints","filter_fe0f","cps","cp","ens_normalize_post_check","_step","_iterator","_createForOfIteratorHelper","s","label","lastIndexOf","every","err","e","f","ens_normalize","emoji_filter","input","output","emoji","consume_emoji_reversed","apply","_toConsumableArray","pop","has","toUpperCase","fromCodePoint","normalize","eaten","saved","stack","_a","find","splice","Zeros","checkComponent","comp","ensNameSplit","comps","last","namehash","ethDefaultProvider","network","providers","providerList","InfuraProvider","infura","EtherscanProvider","etherscan","AlchemyProvider","alchemy","PocketProvider","pocket","provider","CloudflareProvider","cloudflare","AnkrProvider","ankr","FallbackProvider","quorum","renetwork","etcDefaultProvider","JsonRpcProvider","homestead","ensAddress","_defaultProvider","ropsten","classicMordor","networks","unspecified","mainnet","morden","testnet","rinkeby","kovan","goerli","kintsugi","sepolia","classic","classicMorden","classicTestnet","classicKotti","xdai","matic","maticmum","optimism","arbitrum","bnb","bnbt","sha256","update","digest","Formatter","formats","getDefaultFormats","address","bind","bigNumber","blockTag","hex","number","transaction","accessList","allowNull","blockHash","blockNumber","transactionIndex","confirmations","gasPrice","maxPriorityFeePerGas","maxFeePerGas","gasLimit","to","nonce","uint256","creates","raw","transactionRequest","receiptLog","transactionHash","topics","arrayOf","logIndex","receipt","contractAddress","root","gasUsed","logsBloom","logs","cumulativeGasUsed","effectiveGasPrice","block","parentHash","timestamp","difficulty","miner","extraData","transactions","baseFeePerGas","blockWithTransactions","transactionResponse","fromBlock","toBlock","filterLog","removed","boolean","allowFalsish","accessListify","toNumber","strict","hexDataSlice","getContractAddress","hexValue","hexDataLength","format","author","_difficulty","_block","gas","isZero","networkId","parseTransaction","byzantium","object","checkKey","checkValue","nullValue","replaceValue","checkTopic","topic","serializeTopics","unique","getEventTag","eventName","ForkEvent","warn","getTime","Date","PollableEvents","Event","tag","listener","_lastBlockNumber","_inflight","coinInfos","symbol","p2pkh","p2sh","prefix","ilk","bytes32ify","base58Encode","matcherIpfs","matchers","_parseString","_parseBytes","getIpfsLink","link","numPad","padded","bytesPad","ceil","encodeBytes","datas","byteCount","Resolver","resolvedAddress","formatter","_supportsEip2544","eq","catch","selector","parameters","tx","ccipReadEnabled","parseBytes","supportsWildcard","_fetch","_context2","_callee2","coinType","hexBytes","coinInfo","operation","words","bech32","_context3","callAddress","_fetchBytes","_getAddress","_callee3","linkage","content","_context4","getText","avatar","scheme","_resolvedAddress","owner","addr","tokenId","t2","t3","tokenOwner","t4","t5","balance","t6","t7","metadataUrl","metadata","imageUrl","image","t8","_callee4","_context5","ipfs","ipns","swarm","skynet","urlSafe","_callee5","keyBytes","_context6","_callee6","defaultFormatter","nextPollId","BaseProvider","_Provider","_inherits","_super","_createSuper","_events","_emitted","disableCcipRead","constructor","getFormatter","_assertThisInitialized","anyNetwork","detectNetwork","_networkPromise","_ready","knownNetwork","getStatic","emit","_maxInternalBlockNumber","_maxFilterBlockRange","_pollingInterval","_fastQueryDate","_network","_context7","_callee7","_this3","event","calldata","urls","_context8","sender","errorMessages","errorMessage","_callee8","maxAge","_context9","_internalBlockNumber","internalBlockNumber","respTime","reqTime","checkInternalBlockNumber","resolveProperties","perform","networkError","getNetwork","_this4","_setFastBlockNumber","_callee9","pollId","runners","_context10","_getInternalBlockNumber","pollingInterval","abs","previousBlockNumber","eventBlockNumber","_this5","runner","getTransactionReceipt","minFromBlock","getLogs","log","_callee10","polling","_context11","_callee11","_context12","currentNetwork","_fastBlockNumber","_fastBlockNumberPromise","detectedNetwork","_callee12","_this6","_poller","_this7","setInterval","_bootstrapPoll","clearInterval","_this8","_this9","now","getBlockNumber","_waitForTransaction","_context13","_callee13","replaceable","_context16","cancelFuncs","alreadyDone","minedHandler","_this10","on","removeListener","lastBlockNumber","startBlock","scannedBlock","replaceHandler","__awaiter","mark","_callee15","_this11","wrap","_context15","getTransactionCount","_callee14","mined","ti","_receipt","reason","_context14","getTransaction","getBlockWithTransactions","waitForTransaction","cancelled","replacement","_wrapTransaction","unref","_callee16","_context17","_callee17","_context18","_callee18","addressOrName","_context19","_getBlockTag","params","_callee19","_context20","_callee20","_context21","_callee21","position","_context22","p","_callee22","_this12","expectedHash","returnedHash","wait","confirms","_callee23","_context23","signedTransaction","_context24","hexTx","_callee24","_context25","_this13","_callee25","_context26","_this14","_callee26","redirects","txSender","_context27","signature","urlsOffset","urlsLength","urlsData","u","callbackSelector","ccipReadFetch","ccipResult","_call","_callee27","_context28","_getTransactionRequest","resolved","_callee28","_context29","_callee29","_context30","_callee30","blockHashOrBlockTag","includeTransactions","_context32","_this15","_callee31","_blockNumber","blockWithTxs","_this16","_context31","_callee32","_getBlock","_context34","_this17","_callee33","_context33","_callee34","_context36","_this18","_callee35","_context35","_callee36","_context37","_getFilter","_callee37","_context38","_callee38","_context39","_callee39","currentName","_context40","_getResolver","resolver","_callee40","_context41","addrData","_callee41","_context42","getResolver","_callee42","_context43","resolverAddr","_callee43","nameOrAddress","_context44","resolverAddress","getAvatar","_callee44","pollable","_startEvent","_addEventListener","_this19","_len","arguments","args","_key","stopped","eventTag","_stopEvent","_this20","removeAllListeners","_this21","standard","defaultProvider","Provider","errorGas","spelunk","requireData","checkError","responseText","getResult","payload","getLowerCase","_constructorGuard","JsonRpcSigner","_Signer","constructorGuard","addressOrIndex","UncheckedJsonRpcSigner","_address","_index","send","accounts","fromAddress","estimate","estimateGas","hexlifyTransaction","action","sendUncheckedTransaction","messageData","_TypedDataEncoder","populated","Signer","_JsonRpcSigner","_super2","allowedTransactionKeys","_BaseProvider","_super3","networkOrReady","_nextId","_eventLoopCache","_cache","_uncachedDetectNetwork","getSigner","connectUnchecked","jsonrpc","getFeeData","feeData","prepareRequest","_startPending","_get","_getPrototypeOf","prototype","_pendingFilter","self","pendingFilter","filterId","hashes","seq","listenerCount","allowExtra","allowed","checkProperties","buildWeb3LegacyFetcher","sendFunc","fetcher","Web3Provider","_JsonRpcProvider","path","jsonRpcFetchFunc","subprovider","host","isMetaMask","buildEip1193Fetcher","sendAsync","throwFault","fault","zeros","getMultiplier","decimals","formatFixed","multiplier","negative","fraction","mod","whole","div","parseFixed","wholeValue","fractionValue","wei","FixedFormat","_multiplier","defaultValue","FixedNumber","_hex","_value","_isFixedNumber","other","_checkFormat","fromValue","sub","hasFraction","isNegative","subUnsafe","ONE","toFormat","addUnsafe","factor","bump","BUMP","mulUnsafe","divUnsafe","fromTwos","parseFloat","fromString","isBigNumberish","fixedFormat","numeric","decimal","isBytes","fromBytes","names","formatEther","unitName","index","formatUnits","parseEther","ether","parseUnits","ALPHABET","ALPHABET_MAP","z","polymodStep","pre","prefixChk","chk","c","__decode","str","LIMIT","lowered","uppered","wordChars","convert","inBits","outBits","pad","bits","maxV","module","exports","decodeUnsafe","res","toWordsUnsafe","toWords","fromWordsUnsafe","fromWords"],"sourceRoot":""}